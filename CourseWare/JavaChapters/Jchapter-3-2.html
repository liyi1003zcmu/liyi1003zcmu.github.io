<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Java程序设计--Java基础语法</title>
    <meta name="description" content="关于Java的基本信息">
    <meta name="author" content="Liyi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobil-web-app-status-bar-style" content="black">

    <link rel="stylesheet" href="../../dist/reset.css">
    <link rel="stylesheet" href="../../dist/reveal.css">
    <link rel="stylesheet" href="../../dist/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" id="highligh">

    <style type="text/css">
        .columnleft{
            float: left;
            width: 50%;
        }
        .columnright{
            float: right;
            width: 50%;
        }
        .li{
            text-align: left;
            font-size: x-large;
        }
        .p{
            text-align: left;
            font-size: x-large;
        }
    </style>
</head>

<body>
        <div class="reveal">
            <div class="slides">
                <section id="titlepage">
                    <h1>Java程序设计</h1>
                    <H2>第三章 数组和字符串(2)</H2>
                    <p id="date"></p>
                    <script>
                        var now = new Date();
                        var year = now.getFullYear();
                        var month = now.getMonth();
                        var day = now.getDate();
                        document.getElementById( "date" ).innerHTML = year + "年" + ( 1 + month ) + "月" + day + "日";
                    </script>
                </section>
                <section id="stringclass">
                    <h2>字符串类(String)</h2>
                    <ul>
                        <li>一串字符，用双引号表示字符串常量，用<strong style="color:red">String</strong>存储字符串常量</li>
                        <pre><code>
String s1 = "hello World!";
String s2 = new String( "Hello, World" );
                        </code></pre>
                        <li>String类有丰富的方法用于字符串操作</li>
                        <pre><code>
String s1 = "Hello";
s1.length();
s1.charAt( 0 );//可将字符串理解为字符数组
                        </code></pre>
                        <li>Java内建了对字符串的支持，可直接对字符串常量调用与String类同样的方法</li>
                        <pre><code>
"Hello World".length();
" hello  ".trim();
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <section id="stringsimplemet">
                        <h2>String类常用方法(一)</h2>
                        <img src="../images/java/chap3/stringsimplemethod.png">

                    </section>
                    <section id="stringsimplemet1">
                        <h2>String类常用方法(一)</h2>
                        <ul>
                            <li>length()方法, 注意和数组的length属性区别</li>
                            <pre><code>
String str = "Welcome to Java";
System.out.println( "The length of " + str + " is " + str.length() );
                            </code></pre>
                            <li>charAt(index)方法，返回字符串在指定位置上的字符</li>
                            <pre><code>
String str = "Welcome to Java";
int index = 0;
System.out.println( "The " + index + "th character of " + str + " is " + str.charAt( index ) );
                            </code></pre>
                            <li>concat()方法，连接两个字符串，构成一个新的字符串</li>
                            <a href="../SourceCode/java/Lec_03_Src/StringConcatTest.java">StringConcatTest.java</a>
                        </ul>
                    </section>
                    <section id="stringsimpelemt2">
                        <h2>String类常用方法(一)</h2>
                        <ul>
                            <li>toLowerCase和toUpperCase()方法，实现字符串的大小写转换</li>
                            <pre><code>
String s1 = "welcome";
String s2 = "WELCOME";
System.out.println( "s1 to upper case: " + s1.toUpperCase() );
System.out.println( "s2 to lower case: " + s2.toLowerCase() );
                            </code></pre>
                            <li>trim()方法，去除字符串头尾部的空白，包括"\t, \n, \f, \r"和空格</li>
                            <pre><code>
String s3 = "\t Good Night \n";
System.out.println( s3.trim() );
                            </code></pre>
                            <li>split()方法，将字符串根据给定字符分割成字符串数组</li>
                            <pre><code>
String s4 = " H E L L O ";
String[] strs = s4.split( " " );
for( String str:strs )
  System.out.print( str );
                            </code></pre>
                        </ul>
                    </section>
                    <section id="stringinput">
                        <h2>从标准输入获取字符串和字符</h2>
                        <ul>
                            <li>输入字符串，利用Scanner类的next()和nextLine()方法</li>
                            <pre><code>
Scanner input = new Scanner( System.in );
String s1 = input.next();
String s2 = input.next();
String s3 = input.next();
System.out.println( "s1 + s2 + s3 is " + s1 + s2 + s3 );

System.out.print( "enter a line" );
String s = input.nextLine();
System.out.println( "s is " + s );
                            </code></pre>
                            <li>从标准输入获取字符，利用字符串的charAt(index)方法</li>
                            <pre><code>
Scanner input = new Scanner( System.in );
String s = input.nextLine();
char ch = s.charAt( 0 );
System.out.println( "The character is " + ch );
                            </code></pre>
                        </ul>
                    </section>
                </section>
                <section>
                    <section id="stringcompmet">
                        <h2>String类常用方法(二)</h2>
                        <img src="../images/java/chap3/stringcomparemethod.png">
                    </section>
                    <section id="stringcompmet1">
                        <h2>String类常用方法(二)</h2>
                        <ul>
                            <li>equals和equalsIgnoreCase方法，比较两个字符串内容是否相同</li>
                            <pre><code>
String s1 = "Welcome";
String s2 = "Welcome";
String s3 = "welcome";
System.out.println( s1.equals( s2 ) );
System.out.println( s1.equals( s3 ) );
System.out.println( s1.equalsIgnoreCase( s3 ) );
                            </code></pre>
                            <li>compareTo和compareToIgnoreCase方法，比较两个字符串的内容，返回整数表示二者大小关系，&gt;0表示大于，0表示相等，&lt;0表示小于</li>
                            <pre><code>
System.out.println( s1.compareTo( s2 ) );
System.out.println( s1.compareTo( s3 ) );
System.out.println( s1.compareToIgnoreCase( s3 ) );
                            </code></pre>
                        </ul>
                    </section>
                    <section id="stringcompmet2">
                        <h2>String类常用方法(二)</h2>
                        <ul>
                            <li>startsWith和endsWith方法，计算一个字符串是否以特定的字符串开头或结尾</li>
                            <pre><code>
System.out.println( s1.startsWith( "We" ) );
System.out.println( s1.startsWith( "we" ) );
System.out.println( s2.endsWith( "me" ) );
                            </code></pre>
                            <li>contains方法，判断一个字符串是否包含某特定字符串</li>
                            <pre><code>
System.out.println( s1.contains( "lco" ) );
System.out.println( s1.contains( "LCO") );
                            </code></pre>
                        </ul>
                    </section>
                </section>
                <section>
                    <section id="stringsubmet">
                        <h2>String类常用方法(三)</h2>
                        <img src="../images/java/chap3/stringsubmethod.png">
                    </section>
                    <section id="stringsubmet1">
                        <h2>String类常用方法(四)</h2>
                        <ul>
                            <li>substring方法，获得字符串的子串，注意方法名的写法</li>
                            <pre><code>
String str = "Welcome to Java";
String substr1 = str.substring( 4 );
String substr2 = str.substring( 0, 11 ) + "HTML";
System.out.println( substr1 );
System.out.println( substr2 );
                            </code></pre>
                            <li>indexOf和lastIndexOf方法，注意方法的不同参数使用</li>
                            <pre><code>
System.out.println( str.indexOf( 'W' ) );
System.out.println( str.indexOf( 'o' ) );
System.out.println( str.indexOf( 'o', 5 ) );
System.out.println( str.indexOf( "come" ) );
System.out.println( str.indexOf( "Java", 5 ) );
System.out.println( str.indexOf( "java", 5 ) );
System.out.println( str.lastIndexOf( 'W' ) );
System.out.println( str.lastIndexOf( 'o' ) );
System.out.println( str.lastIndexOf( 'o', 5 ) );
System.out.println( str.lastIndexOf( "come" ) );
System.out.println( str.lastIndexOf( "Java", 5 ) );
System.out.println( str.lastIndexOf( "java", 5 ) );
                            </code></pre>
                        </ul>
                    </section>
                </section>
                <section>
                    <section id="basicpack">
                        <h2>基本数据类型的包装类</h2>
                        <p>针对八种基本数据类型，提供对应的包装类，用于实现类型间转换，如数字与字符串间的转换；也可作为参数传入相应方法，如各种泛型类方法，要求参数类型为Object类，基本数据类型无法传入</p>
                        <ul>
                            <li>byte &rarr; Byte</li>
                            <li>char &rarr; Character</li>
                            <li>short &rarr; Short</li>
                            <li>int &rarr; Integet</li>
                            <li>long &rarr; Long</li>
                            <li>float &rarr; Float</li>
                            <li>double &rarr; Double</li>
                            <li>boolean &rarr; Boolean</li>
                        </ul>
                    </section>
                    <section id="basicpack1">
                        <h2>基本数据类型的包装类</h2>
                        <ul>
                            <li>包装类和基本数据类型之间的转换，以int和integer为例</li>
                            <pre><code>
int n = 10;
Integer N = new Integer( n );
int m = N.intValue();
                            </code></pre>
                            <li>JDK 1.5以后提供了自动装箱和拆箱的机制，当表达式中出现基本数据类型与包装类转换需求时，会自动进行转换</li>
                            <pre><code>
Integer N = 100; // 自动装箱，相当于new Integer(100)
int n = N; // 自动拆箱，相当于N.intValue();
                            </code></pre>
                        </ul>
                    </section>
                </section>
                <section id="intstringconv">
                    <h2>字符串与数字间的转换</h2>
                    <ul>
                        <li>字符串与数值之间转换，可采用相应包装类的静态方法，以int和Integer为例</li>
                        <li>字符串转换为int，采用Integer.parseInt方法</li>
                        <pre><code>
String s = "1234";
int n1 = Integer.parseInt( s );
int n2 = Integer.parseInt( s, 10 );
int n3 = Integer.parseInt( s, 16 );
int n4 = Integer.parseInt( "0101", 2 );
                        </code></pre>
                        <li>字符串转换为Integer，采用Integer.valueOf方法</li>
                        <pre><code>
Integer n1 = Integer.valueOf( s );
Integer n2 = Integer.valueOf( s, 16 );
Integer n3 = Integer.valueOf( "0101", 2 );
                        </code></pre>
                        <li>数字转换为字符串，用Integer.toString方法</li>
                        <pre><code>
String s = Integer.toString( 1000 );
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <section id="heapandstack">
                        <h2>栈和堆</h2>
                        <ul>
                            <li>栈和堆都是内存中的区域，用于存放不同类型的数据</li>
                            <li>基本数据类型的值存储在<strong style="color:red">栈</strong>中</li>
                            <li>引用数据类型的引用变量存储在<strong style="color:red">栈</strong>中，具体的数据存储在<strong style="color:red">堆</strong>中，由引用变量指向堆中的内容</li>
                            <li>凡用new生成的对象或数组，其变量名存储在栈中，其对象或数组的具体内容存储在堆中</li>
                        </ul>
                    </section>
                    <section id="heapandstack1">
                        <h2>栈和堆</h2>
                        <img src="../images/java/chap3/arrayInit.png">
                    </section>
                    <section id="heapandstack2">
                        <h2>==和equals</h2>
                        <ul>
                            <li>当用"=="进行比较时，比较的是存储在<strong style="color:red">栈</strong>中存储的变量值</li>
                            <li>基本数据类型值可直接使用"=="进行比较</li>
                            <li>对引用数据类型，若使用“=="进行比较，比较的是引用数据类型对象的引用地址</li>
                            <li>对引用数据类型，使用equals方法进行比较，比较的是引用数据类型对象存储在堆中的具体内容</li>
                            <li>引用数据类型都有equals方法可进行比较，基本数据类型只能使用"=="进行比较</li>
                            <li><a href="../SourceCode/java/Lec_03_Src/EqualTest.java">EqualTest.java</a></li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section id="strpools">
                        <h2>字符串创建机制</h2>
                        <figure>
                        <img src="../images/java/chap3/stringpoolillu.png">
                        <figcaption>字符串池</figcaption>
                        </figure>
                    </section>
                    <section id="strpoolexp">
                        <h2>字符串池机制</h2>
                        <ul>
                            <li>字符串池，在“堆”内存中，用于存储已创建的字符串对象</li>
                            <li>当调用String s="hello"时，首先在字符串池中寻找是否已存在此字符串，若有，就将其赋值给s变量(<strong style="color:red">如何解释?</strong>)；若不存在，则在堆中新建一个字符串，记录其地址值，将其地址值赋值给变量s</li>
                            <pre><code>
String s1 = "hello";
String s2 = "hello";
String s3 = new String( "hello" );
System.out.println( "s1==s2? " + (s1==s2) + ", s1==s3? " + (s1==s3) );
System.out.println( "s1.equals(s2)? " + s1.equals( s2 ) + ", s1.equals(s3)? " + s1.equals(s3) );
                            </code></pre>
                        </ul>
                    </section>
                    <section id="strpoolexp2">
                        <h2>字符串池机制(续)</h2>
                        <ul>
                            <li>字符串池中的字符串是常量，一经创建后不能改变其值</li>
                            <pre><code>
String s1 = "hello";
System.out.println( s1.hashCode() );
s1 = "hello2";
System.out.println( s1.hashColde() );
                            </code></pre>
                            <p><a href="../SourceCode/java/Lec_03_Src/StringPoolTest.java">StringPoolTest.java</a></p>
                            <li>String对象的实例是不可改变的，任何字符串操作都会生成新的实例，原有字符串并未发生改变</li>
                            <li>String是一个对象，不是字符数组，末尾没有'\0'</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section id="sbuf">
                        <h2>StringBuffer类</h2>
                        <ul>
                            <li>String类对象实例是不可改变的，若要改变String对象本身的内容，可采用StringBuffer类</li>
                            <pre><code>
StringBuffer sb = new StringBuffer( "Hello" );
int i = 101;
sb.append( " " ).append( "World" ).append( i ); //可任意添加
String str = sb.toString();
                            </code></pre>
                            <p><a href="../SourceCode/java/Lec_03_Src/StringBufferTest.java">StringBufferTest.java</a></p>
                            <li>与使用"+"进行字符串连接相比，StringBuffer直接使用字符数组对内容进行动态扩充，性能要好很多</li>
                            <li>StringBuilder能够提供与StringBuffer类似的功能，但StringBuffer是线程安全的，但StringBuilder不是</li>
                        </ul>
                    </section>
                </section>
            </div>
        </div>

        <script src="../../dist/reveal.js"></script>
        <script src="../../plugin/zoom/zoom.js"></script>
        <script src="../../plugin/notes/notes.js"></script>
        <script src="../../plugin/search/search.js"></script>
        <script src="../../plugin/markdown/markdown.js"></script>
        <script src="../../plugin/highlight/highlight.js"></script>
        <script>
            Reveal.initialize({
               // display controls in the bottom right corner
                controls: true,

                // display a presentation progress bar
                progress: true,
                // set default timing of 2 minutes per slides
                defaultTiming: 120,

                // Display the page number of the current slides
                slideNumber: true,

                // Push each slide change to the browser history
                history: false,

                // Enable keyboard shortcuts for navigation
                keyboard: true,

                // Enable the slide overview mode
                overview: true,

                // Vertical centering of slides
                center: true,

                // Enable touch navigation on devices with touch input
                touch: true,

                // Loop the presentation
                loop: false,

                // Change teh presentation direction to be RTL
                rtl: false,

                // Randomizes the order of slides each time the presentation loads
                shuffle: false,

                // Turns fragments on and off globally
                fragment: true,

                // Flags if the presentation is running in an embedded mode,
                // i.e. contained within a limited portion of the screen
                embedded: false,

                // Flags if we should show a help overlay when the questionmark key is pressed
                help: true,

                // Flags if speaker notes should be visible to all viewers
                showNotes: false,

                // Global override for autoplaying embedded media( video/audio/iframe)
                // - null: media will only autoplay if data-autopay is present
                // - true: all media will autoplay, regradless of individual setting
                // - false: no media will autoplay, regardless of individual setting
                autoPlayMedia: null,

                // Number of milliseconds between automatically proceeding to the next slide,
                //disabled when set to 0, this value can be overwritten by
                // using a data-autoslide attribute on your slides
                autoSlide: 0,

                // Stop auto-sliding after user input
                autoSlideStoppable: true,

                // Use this method for navigation when auto-sliding
                autoSlideMethod: Reveal.navigateNext,

                // Enable slide navigation via mouse wheel
                mouseWheel: false,

                // Hides the address bar on mobile devices
                hideAddressBar: true,

                // Opens links in an iframe preview overlay
                previewLinks: false,

                // Transition style
                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Transition speed
                transitionSpeed: 'default', // default/fast/slow

                // Transition style for full page slide backgrounds
                backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

                // Number of slides away from the current that are visible
                viewDistance: 3,

                // Parallax background image
                parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakin-static/reveal-js/reveal-parallax-1.jpg'"

                // Parallax background size
                parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

                // Number of pixels to move the parallax background per slide
                // - calculated automatically unless specified
                // - set to 0 to disable movement along an axis
                parallaxBackgroundHorizontal: null,
                parallaxBackgroundVertical: null,

                // The display mode that will be used to show slides
                display: 'block',

                // print to pdf while no slide grows to more than one printed page
                pdfMaxPagesPerSlide: 1,

                // presentation
                width: 1000,
                height: 1000,

                margin: 0.1,

                minScale: 0.2,
                maxScale: 1.5,

                plugins: [ RevealHighlight ]
            })
        </script>
    </body>
</html>
