<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>Java程序设计--Java面向对象基础</title>
    <meta name="description" content="关于Java的基本信息">
    <meta name="author" content="Liyi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobil-web-app-status-bar-style" content="black">

    <link rel="stylesheet" href="../../dist/reset.css">
    <link rel="stylesheet" href="../../dist/reveal.css">
    <link rel="stylesheet" href="../../dist/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../../plugin/highlight/monokai.css" id="highligh">

    <style type="text/css">
        .columnleft{
            float: left;
            width: 50%;
        }
        .columnright{
            float: right;
            width: 50%;
        }
        .li{
            text-align: left;
            font-size: x-large;
        }
        .p{
            text-align: left;
            font-size: x-large;
        }
    </style>
</head>

<body>
        <div class="reveal">
            <div class="slides">
                <section id="titlepage">
                    <h1>Java程序设计</h1>
                    <H2>第四章 面向对象基础(二)</H2>
                    
                    <p id="date"></p>
                    <script>
                        var now = new Date();
                        var year = now.getFullYear();
                        var month = now.getMonth();
                        var day = now.getDate();
                        document.getElementById( "date" ).innerHTML = year + "年" + ( 1 + month ) + "月" + day + "日";
                    </script>
                </section>
                <section>
                    <h2>父类和子类</h2>
                    <img src="../images/java/chap4/classextends.png">
                    <p><a href="../SourceCode/java/java/Lec_04_Src/Geometry.java" target="_blank">Geometry.java</a>
                    <a href="../SourceCode/java/java/Lec_04_Src/Circle.java" target="_blank">Circle.java</a>
                    <a href="../SourceCode/java/java/Lec_04_Src/Rectangle.java" target="_blank">Rectangle.java</a>
                </section>
                <section>
                    <section>
                        <h2>父类和子类的关系</h2>
                        <ul>
                            <li>子类不是父类的子集，往往含有比父类更多的信息</li>
                            <li>子类不能直接访问父类的私有数据域</li>
                            <li>不是所有的“is-a"关系都能用继承关系进行建模，如”正方形与长方形“的关系</li>
                            <li>不要为了重用方法，滥用”is-a"关系，比如“树和人”</li>
                            <li>Java中只有单一继承，没有多继承</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Object类</h2>
                        <p>Object类是所有类的直接或间接父类</p>
                        <p>主要的Object类方法包括:</p>
                        <ul>
                            <li>public final Class getClass() 获取当前对象所属的类信息，返回class对象</li>
                            <li>public String toString() 按字符串对象返回当前对象本身有关的信息</li>
                            <li>public boolean equals(Object obj) 比较两个对象是否是同一对象</li>
                            <li>protected Object clone() 生成当前对象的一个副本，并返回该对象副本</li>
                            <li>public int hashCode() 返回该对象的哈希代码值</li>
                            <li>protected void finalize() throws Throwable 定义回收当前对象时所需要完成的资源释放工作</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>Super关键字</h2>
                        <p>super关键字用于指代父类</p>
                        <ul>
                            <li>子类继承的是具有访问权限的数据域和方法</li>
                            <li>构造方法不能继承</li>
                            <li>可利用super调用父类构造方法</li>
                            <li>可利用super调用父类方法</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Super关键字</h2>
                        <ul>
                            <li>可通过super()或super(par)调用父类构造方法</li>
                            <li>若显式调用super()或super(par)，则该语句必须为子类构造方法的第一句</li>
                            <li>子类构造方法若没有<strong>重载</strong>父类的构造方法，或采用super显式调用父类的构造方法，编译器将自动在每个构造方法中在第一句位置加入super()语句</li>
                        </ul>
                    </section>
                    <section>
                        <h2>构造方法的调用</h2>
                        <p>构造方法的调用会沿着继承的关系找到所有的父类构造方法</p>
                        <img src="../images/java/chap4/sclasscall.png">
                    </section>
                    <section>
                        <h2>super的说明</h2>
                        <ul>
                            <li>类需要被继承和扩展的话，需要提供无参构造方法</li>
                            <li>可利用super调用父类的方法，如super.method(par)</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>访问权限修饰符</h2>
                        <ul>
                            <li>public 可被任意其它对象访问</li>
                            <li>private 只能被类本身访问，在类外不可访问</li>
                            <li>protected 只能被同一包内及其子类的实例对象访问</li>
                            <li>默认(friendly) 可被类所在包内的各类访问</li>
                        </ul>
                    </section>
                    <section>
                        <h2>访问权限修饰符</h2>
                        <table style="font-size:x-large">
                            <tr style="background-color:sienna">
                                <th>类型</th>
                                <th>无修饰符</th>
                                <th>public</th>
                                <th>private</th>
                                <th>protected</th>
                            </tr>
                            <tr>
                                <th>同一类</th>
                                <th>是</th>
                                <th>是</th>
                                <th>是</th>
                                <th>是</th>
                            </tr>
                            <tr>
                                <th>同一包中的子类</th>
                                <th>是</th>
                                <th>是</th>
                                <th>否</th>
                                <th>是</th>
                            </tr>
                            <tr>
                                <th>同一包中的非子类</th>
                                <th>是</th>
                                <th>是</th>
                                <th>否</th>
                                <th>是</th>
                            </tr>
                            <tr>
                                <th>不同包中的子类</th>
                                <th>否</th>
                                <th>是</th>
                                <th>否</th>
                                <th>是</th>
                            </tr>
                            <tr>
                                <th>不同包中的非子类</th>
                                <th>否</th>
                                <th>是</th>
                                <th>否</th>
                                <th>否</th>
                            </tr>
                        </table>
                    </section>
					<section>
						<h2>访问权限修饰符</h2>
						<img src="../images/java/chap4/classescall.png">
						<table style="font-size:x-large">
                            <tr>
								<th>o.x</th>
								<th>Y</th>
								<th>Y</th>
							</tr>
							<tr>
								<th>o.y</th>
								<th>Y</th>
								<th>N</th>
							</tr>
							<tr>
								<th>o.z</th>
								<th>N</th>
								<th>N</th>
							</tr>
							<tr>
								<th>o.m1</th>
								<th>Y</th>
								<th>Y</th>
							</tr>
							<tr>
								<th>o.m2</th>
								<th>Y</th>
								<th>N</th>
							</tr>
							<tr>
								<th>o.m3</th>
								<th>N</th>
								<th>N</th>
							</tr>
						</table>
					</section>
					<section>
						<h2>访问权限修饰符</h2>
						<img src="../images/java/chap4/classescall2.png">
						<table style="font-size:x-large">
							<tr>
								<th>C1</th>
								<th>Y</th>
								<th>N</th>
							</tr>
							<tr>
								<th>C2</th>
								<th>Y</th>
								<th>Y</th>
							</tr>
						</table>
					</section>
					<section>
						<h2>访问权限修饰符</h2>
						<pre style="font-size:45%">
						<code class="hljs" data-trim data-line-numbers>
public class Foo{
  private boolean c;
  public static void main(String[] args){
    Foo foo=new Foo();
	System.out.println(foo.x);
	System.out.println(foo.convert());
  }
  private int convert(){
    return x?1:-1;
  }
}
						</code></pre>
						<pre style="font-size:45%">
						<code class="hljs" data-trim data-line-numbers>
public class Test{
  public static void main(String[] args){
    Foo foo=new Foo();
	System.out.println(foo.x);
	System.out.println(foo.convert());
  }
}
						</code></pre>
					</section>
                </section>
				<section>
					<section>
						<h2>方法重写</h2>
						<ul>
							<li>方法重写，指的是若子类不需要使用从父类继承的方法功能时，可以定义自己的方法</li>
							<li>子类的方法具有和父类方法相同的参数，相同的返回类型</li>
							<li>只可重写子类具有访问权限的方法，方法的访问范围不能比原方法小</li>
							<li>不可重写super.super.toString()方法</li>
							<li>不可重写父类的private方法</li>
							<li>不可重写父类的静态方法</li>
						</ul>
					</section>
					<section>
						<h2>方法重载</h2>
						<ul>
							<li>方法重载，指的是具有相同的方法名，不同的方法参数，不同的方法返回类型的方法</li>
							<li>可以在同一个类中有多个重载的成员方法</li>
							<li>注意重载与重写的区别</li>
						</ul>
					</section>
					<section>
						<h2>方法重写和重载</h2>
						<div class="columnleft">
						<p>重写</p>
						<pre style="font-size:45%">
						<code class="hljs" data-trim data-line-numbers>
public class Test{
  public static void main(String[] args){
    A a=new A();
	a.p(10);
	a.p(10.0);
  }
}
class B{
  public void p(double i){
    System.out.println(i*2);
  }
}
class A extends B{
  public void p(double i){
    System.out.println(i);
  }
}
						</code></pre>
						</div>
						<div class="columnright">
						<p>重载</p>
						<pre style="font-size:45%">
						<code class="hljs" data-trim data-line-numbers>
public class Test{
  public static void main(String[] args){
    A a=new A();
	a.p(10);
	a.p(10.0);
  }
}
class B{
  public void p(double i){
    System.out.println(i*2);
  }
}
class A extends B{
  public void p(int i){
	System.out.println(i);
  }
}
						</code></pre>
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>多态性</h2>
						<img src="../images/java/chap4/polymorph.png">
						<p>在将父类对象作为参数的方法中，可将子类对象作为参数进行传递 <a href="../SourceCode/java/java/Lec_04_Src/PolymorphismDemo.java">PolymorphismDemo.java</a></p>
					</section>
					<section>
						<h2>动态绑定</h2>
						<img src="../images/java/chap4/dynamicbinding.png">
						<ul>
							<li>$C_n$为Object类，$C_1$为最特殊的类，obj为$C_1$的一个实例</li>
							<li>obj.p()方法实现时，虚拟机在$C_1$,$C_2$,$\cdots$,$C_k$,$\cdots$,$C_{n-1}$,$C_n$中查找p的实现，一旦找到就停止查找并调用该实现</li>
							<li><a href="../SourceCode/java/java/Lec_04_Src/DynamicBindingDemo.java">DynamicBindingDemo.java</a></li>
							<li>注意区分方法的匹配和绑定实现，匹配发生在编译时，而绑定是在运行时动态进行</li>
						</ul>
					</section>
				</section>
                <section>
                    <section>
                        <h2>对象类型转换</h2>
                        <img src="../images/java/chap4/hiddenconv.png">
                        <p>隐式转换，Student类的实例对象自动成为Object类的实例对象</p>
                        <div>
                            <div class="columnleft">
                                <pre><code>
Object o=new Student();
Student s=o;
                                </code></pre>
                                <p>$\times$</p>
                            </div>
                            <div class="columnright">
                                <pre><code>
Object o=new Student();
Student s=(Student)o;
                                </code></pre>
                                <p>$\checkmark$</p>
                            </div>
                        </div>
                        <p>显式转换，将父类对象实例转换为子类对象实例时，必须使用显式转换</p>
                    </section>
                    <section>
                        <h2>对象类型转换(2)</h2>
                        <p>instanceof运算符，用于检测某个对象是否是一个类的实例</p>
                        <pre><code>
Object myObject=new Circle();
//...
if(myObject instanceof Circle){
  System.out.println("The circle diameter is "+
    ((Circle)myObject).getDiameter());
}
                        </code></pre>
                    </section>
                </section>
                <section>
                    <h2>对象相等判断</h2>
                    <ul>
                        <li>equals方法，用于比较两个对象的内容，可重写</li>
                        <li>==用于比较两个基本数据类型的变量值是否相等，或者两个引用变量的地址是否相等，即指向同一对象</li>
                    </ul>
                    <pre><code>
object1.equals(object2);

public boolean equals(Object obj){
  return this==obj;
}
                    </code></pre>
                </section>
                <section>
                    <h2>关于final</h2>
                    <ul>
                        <li>final可用于修饰类、类的成员、局部变量</li>
                        <li>final类不可被继承</li>
                        <li>final变量是一个常量</li>
                        <li>父类中的final方法不可被子类重写</li>
                    </ul>
                    <pre><code>
public final class FC{
  //......
}

final static double PI=3.14159265;
public class Test{
  public final void m(){
    //......
  }
}
                    </code></pre>
                </section>
            </div>
        </div>

        <script src="../../dist/reveal.js"></script>
        <script src="../../plugin/zoom/zoom.js"></script>
        <script src="../../plugin/notes/notes.js"></script>
        <script src="../../plugin/search/search.js"></script>
        <script src="../../plugin/markdown/markdown.js"></script>
        <script src="../../plugin/highlight/highlight.js"></script>
        <script src="../../plugin/math/math.js"></script>
        <script>
            Reveal.initialize({
               // display controls in the bottom right corner
                controls: true,

                // display a presentation progress bar
                progress: true,
                // set default timing of 2 minutes per slides
                defaultTiming: 120,

                // Display the page number of the current slides
                slideNumber: true,

                // Push each slide change to the browser history
                history: false,

                // Enable keyboard shortcuts for navigation
                keyboard: true,

                // Enable the slide overview mode
                overview: true,

                // Vertical centering of slides
                center: true,

                // Enable touch navigation on devices with touch input
                touch: true,

                // Loop the presentation
                loop: false,

                // Change teh presentation direction to be RTL
                rtl: false,

                // Randomizes the order of slides each time the presentation loads
                shuffle: false,

                // Turns fragments on and off globally
                fragment: true,

                // Flags if the presentation is running in an embedded mode,
                // i.e. contained within a limited portion of the screen
                embedded: false,

                // Flags if we should show a help overlay when the questionmark key is pressed
                help: true,

                // Flags if speaker notes should be visible to all viewers
                showNotes: false,

                // Global override for autoplaying embedded media( video/audio/iframe)
                // - null: media will only autoplay if data-autopay is present
                // - true: all media will autoplay, regradless of individual setting
                // - false: no media will autoplay, regardless of individual setting
                autoPlayMedia: null,

                // Number of milliseconds between automatically proceeding to the next slide,
                //disabled when set to 0, this value can be overwritten by
                // using a data-autoslide attribute on your slides
                autoSlide: 0,

                // Stop auto-sliding after user input
                autoSlideStoppable: true,

                // Use this method for navigation when auto-sliding
                autoSlideMethod: Reveal.navigateNext,

                // Enable slide navigation via mouse wheel
                mouseWheel: false,

                // Hides the address bar on mobile devices
                hideAddressBar: true,

                // Opens links in an iframe preview overlay
                previewLinks: false,

                // Transition style
                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Transition speed
                transitionSpeed: 'default', // default/fast/slow

                // Transition style for full page slide backgrounds
                backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

                // Number of slides away from the current that are visible
                viewDistance: 3,

                // Parallax background image
                parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakin-static/reveal-js/reveal-parallax-1.jpg'"

                // Parallax background size
                parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

                // Number of pixels to move the parallax background per slide
                // - calculated automatically unless specified
                // - set to 0 to disable movement along an axis
                parallaxBackgroundHorizontal: null,
                parallaxBackgroundVertical: null,

                // The display mode that will be used to show slides
                display: 'block',

                // print to pdf while no slide grows to more than one printed page
                pdfMaxPagesPerSlide: 1,

                // presentation
                width: 1000,
                height: 1000,

                margin: 0.1,

                minScale: 0.2,
                maxScale: 1.5,

                math: {
                    mathjax: 'https://cdn.jsdelivr.net/gh/mathjax/mathjax@2.7.8/MathJax.js',
                    config: 'TeX-AMS_HTML-full',
                    // pass other options into `MathJax.Hub.Config()`
                    TeX: { Macros: { RR: "{\\bf R}" } }
                },

                plugins: [RevealHighlight, RevealMath]
            })
        </script>
    </body>
</html>
