<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>计算机图形学-纹理映射</title>

    <meta name="description" content="纹理映射">
    <meta name="author" content="Liyi">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobil-web-app-status-bar-style" content="black">
    
    <link rel="stylesheet" href="../../../dist/reset.css">
    <link rel="stylesheet" href="../../../dist/reveal.css">
    <link rel="stylesheet" href="../../../dist/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../../../plugin/highlight/monokai.css" id="highligh">
    
    <style>
        .interactive-placeholder {
            width: 100%;
            height: 550px;
            background-color: #f0f8ff;
            border: 2px dashed #a0c4e4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px auto;
            text-align: left;
            color: #4682b4;
            font-size: 0.7em;
            padding: 20px;
            box-sizing: border-box;
            border-radius: 10px;
        }
        .interactive-placeholder h4 {
            margin-top: 0;
            color: #2a5a8a;
        }
        /* Custom styles for image placeholders */
        .placeholder {
            border: 2px dashed #ccc;
            background-color: #f9f9f9;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #888;
            font-size: 1.2em;
            height: 400px;
            width: 100%;
            margin: 10px 0;
            box-sizing: border-box;
        }
        .placeholder-half {
            width: 48%;
            display: inline-block;
            vertical-align: top;
        }
        .reveal strong {
            color: #2a76dd;
        }

        .reveal p, .reveal dd{
            font-size:24pt;
            text-align:left;
        }
        .reveal li{
            font-size:24pt;
            text-align:left;
        }
        .reveal dt{
            font-size:28pt;
            color:red;
            font-weight:bold;
        }

        .two-column {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .three-column {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .four-column {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .two-column > div {
            width: 48%;
        }

        .three-column > div {
            width: 30%;
        }
        
        .four-column > div {
            width: 22%;
        }
    </style>
    <style>
        /* Styles for the interactive application */
        .app-container {
            display: flex;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            gap: 20px;
            font-size: 14px;
            height: 550px;
        }
        .controls-panel { flex: 1; display: flex; flex-direction: column; gap: 15px; }
        .canvas-panel { flex: 1.5; border: 1px solid #ccc; border-radius: 8px; }
        .control-group { background-color: #f8f9fa; padding: 10px; border-radius: 8px; }
        .control-group h5 { margin: 0 0 10px 0; }
        #transform-list { list-style: none; padding: 0; margin: 0; min-height: 150px; border: 1px dashed #ccc; border-radius: 8px; background-color: white;}
        #transform-list li {
            padding: 8px;
            background-color: #fff;
            border: 1px solid #ddd;
            margin: 5px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #transform-list li.dragging { opacity: 0.5; background: #eef; }
        .param-inputs { display: flex; gap: 5px; align-items: center; }
        .param-inputs label { font-size: 0.9em; }
        .param-inputs input { width: 50px; }
        .delete-btn { margin-left: auto; background: #ff4d4d; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; cursor: pointer; line-height: 20px; text-align: center; font-weight: bold;}
        .matrix-display { font-family: 'Courier New', Courier, monospace; background-color: #e9ecef; padding: 10px; border-radius: 4px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; text-align: right; }
        .matrix-display span { padding: 2px 5px; background: white; border-radius: 2px; }
    </style>
    <style>
        .reveal .image-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio (divide 9 by 16 = 0.5625) */
            height: 0;
        }

        .interactive-container {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            font-family: sans-serif;
        }
        .controls-formulas {
            flex: 1;
            font-size: 0.6em;
            text-align: left;
        }
        .canvas-container {
            flex: 2;
        }
        #rotation-canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            cursor: grab;
        }
         #rotation-canvas:active {
            cursor: grabbing;
        }
        .formula-display p {
            margin: 5px 0;
        }
        .formula-highlight-x {
             background-color: #fff8c4;
             padding: 2px 4px;
             border-radius: 3px;
        }
        .formula-highlight-y {
             background-color: #e8ffed;
             padding: 2px 4px;
             border-radius: 3px;
        }
        .formula {
            margin: 20px 0;
        }

        #arbitrary-rotation-canvas {
            border: 1px solid #ccc;
            border-radius: 8px;
            cursor: grab;
        }
        #arbitrary-rotation-canvas:active {
            cursor: grabbing;
        }
        #composite-3d-canvas { 
            border: 1px solid #ccc; 
            border-radius: 8px; 
        }
        .reason-box { 
            background-color: #f8f9fa; 
            border-left: 5px solid #ffc107; 
            padding: 15px; 
            margin-top: 20px; 
        }
        .note-box {
            background-color: #e8f4f8;
            border-left: 5px solid #17a2b8;
            padding: 15px;
            margin-top: 20px;
        }
        .warning-box {
            background-color: #fff3cd;
            border-left: 5px solid #dc3545;
            padding: 15px;
            margin-top: 20px;
        }
        
        /* 3D transform styles */
        .matrix-display-3d {
            font-family: 'Courier New', Courier, monospace;
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            text-align: right;
        }
        .matrix-display-3d span {
            padding: 2px 5px;
            background: white;
            border-radius: 2px;
        }

    </style>
    <style type="text/css">
            .columnleft {
                float: left;
                width: 50%;
            }
            .columnright{
                float: right;
                width: 50%;
            }
    </style>
    <style>
        .quiz-container {
            font-size: 24px;
        }
        .quiz-options {
            list-style-type: none;
            padding: 0;
            margin-top: 20px;
        }
        .quiz-options li {
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .quiz-options li:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        .quiz-options li.selected.correct {
            background-color: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
            font-weight: bold;
        }
        .quiz-options li.selected.incorrect {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .answer-explanation {
            margin-top: 30px;
            padding: 20px;
            background-color: #e9ecef;
            border-left: 5px solid #495057;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .answer-explanation strong {
            color: #2a76dd;
        }
    </style>
    <style>
        :root {
            --r-main-font: "Inter", "Microsoft YaHei", "Hiragino Sans GB", sans-serif;
            --r-heading-font: "Inter", "Microsoft YaHei", "Hiragino Sans GB", sans-serif;
            --r-code-font: "Fira Code", "Consolas", monospace;
        }
        .memory-layout {
            font-family: var(--r-code-font);
            font-size: 0.8em;
            text-align: left;
            background: #b3dcf0;
            color: #0c0e0f;
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
        }
        .pixel-r { color: #ff6b6b; }
        .pixel-g { color: #6bff6b; }
        .pixel-b { color: #6b6bff; }
        .pixel-a { color: #dddddd; }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <!-- Slide 1: Title -->
            <section id="titlepage">
                <h1>计算机图形学</h1>
                <h2>第六章(2) 纹理映射</h2>
                
                <p id="date" style="font-size:28pt;text-align:center"></p>
                <script>
                    var now = new Date();
                    var year = now.getFullYear();
                    var month = now.getMonth();
                    var day = now.getDate();
                    document.getElementById( "date" ).innerHTML = year + "年" + ( 1 + month ) + "月" + day + "日";
                </script>
            </section>
            <section>
                <section>
                    <h3>从一只“猴子”开始</h3>
                    <div class="two-column">
                        <div>
                            <img class="fragment" src="images/chap06/ch06-suzanne-render.png" alt="Suzanne Model" style="height:100%;border:2px solid #ccc;border-radius:8px;">
                            <p class="fragment" style="text-align:center"><small>Suzanne 模型(三维空间中的点)</small></p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-suzanne-uvmap.png" alt="Suzanne UV Map" style="height:100%;border:2px solid #ccc;border-radius:8px;">
                            <p class="fragment" style="text-align:center"><small>Suzanne 的 UV 展开图(二维纹理空间)</small></p>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>如何画”猴子“</h3>
                    <p class="fragment">VBO中存储了逐顶点的属性，如位置$(x,y,z)$，法线$(nx,ny,nz)$</p>
                    <p class="fragment">纹理对象是VRAM中的一块内存，存储了图像数据</p>
                    <p class="fragment">要应用纹理对象，需要有另一组关键数据：<strong>UV坐标</strong>，即纹理坐标</p>
                    <p class="fragment">UV坐标如何计算？</p>
                </section>
            </section>
            <section>
                <h3>学习目标</h3>
                <ul>
                    <li>理解纹理映射的基本概念和本质</li>
                    <li>掌握UV坐标的定义与计算方法</li>
                    <li>推导两种不同类型的纹理映射函数</li>
                    <li>分析纹理映射程序实现中存在的问题</li>
                </ul>
            </section>
            <section>
                <section>
                    <h3>"桔子”建模</h3>
                    <div class="two-column">
                        <div>
                            <p class="fragment">以桔子建模为例</p>
                            <ul>
                                <li class="fragment">从一个球体用桔子表皮颜色着色开始</li>
                                <li class="fragment">对球体外形进行逐步细化，使其接近桔子的真实形状</li>
                                <li class="fragment">但存在两个问题：
                                    <ul>
                                        <li>无法完全表达桔子表面结构的特点，如各种表面的小凸起</li>
                                        <li>用于表达小凸起会产生大量的多边形</li>
                                    </ul>
                                </li>
                                <li class="fragment">拍一张桔子的照片，将其”粘“到球体上，即<strong>纹理映射(Texture Mapping)</strong></li>
                                <li class="fragment">如果表面还是太光滑，可以改变局部的形状，即<strong>凹凸映射(Bump Mapping)</strong></li>
                            </ul>
                        </div>
                        <div>
                            <img class="fragment" data-fragment-index="1" src="../../images/cg/chap06/ch06-orange.png" alt="Orange Modeling" style="width:70%;border:0px solid #ccc;border-radius:8px;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>纹理映射的概念</h3>
                    <p class="fragment"><strong>纹理映射</strong>，即指用于将二维的纹理图像“粘贴”到三维物体表面，使三维模型看起来更具视觉真实感。关键在于建立三维物体<strong>表面点</strong>与<strong>纹理图像上的点</strong>的对应关系，即纹理坐标</p>
                    <p class="fragment"><strong>环境映射</strong>，反射贴图(Environment mapping)，用环境图片作为纹理映射，可模拟高反射表面</p>
                    <p class="fragment"><strong>凹凸映射</strong>，Bump mapping，通过扰动法线向量来模拟表面细节，形成表面凹凸的效果</p>
                    <div class="four-column">
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-orange-shaded.png" alt="orange shaded" style="width:100%;">
                            <p class="fragment" style="text-align:center">几何模型平滑着色</p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-orange-texmap.png" alt="orange texmap" style="width:100%;">
                            <p class="fragment" style="text-align:center">纹理映射</p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-orange-envirmap.png" alt="orange environment map" style="width:100%;">
                            <p class="fragment" style="text-align:center">环境映射</p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-orange-bumpmap.png" alt="orange bump map" style="width:100%;">
                            <p class="fragment" style="text-align:center">凹凸映射</p>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>映射处理</h3>
                    <p class="fragment">纹理映射在渲染流水线的最后阶段实现，此时面片已完成了裁剪处理，因此效率很高</p>
                    <img class="fragment" src="../../images/cg/chap06/ch06-pixelpip.png" alt="Texture Mapping Pipeline" style="width:60%;">
                </section>
            </section>
            <section>
                <section>
                    <h3>映射原理</h3>
                    <p class="fragment">纹理映射，其基本原理是将<strong>二维图像</strong>映射到<strong>三维物体表面</strong>，其实现涉及多个坐标系间的转换</p>
                    <div class="two-column">
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-texcoordmap.png" alt="texture coordinate" style="width:60%;">
                        </div>
                        <div>
                            <p class="fragment">纹理映射过程中涉及的坐标系包括：</p>
                            <ul>
                                <li class="fragment"><strong>参数坐标</strong>，用于描述物体表面曲线或曲面</li>
                                <li class="fragment"><strong>纹理坐标</strong>，用于标识图像中用于映射的点</li>
                                <li class="fragment"><strong>对象坐标或世界坐标</strong>，理论上是纹理映射实际发生的坐标系统</li>
                                <li class="fragment"><strong>窗口坐标</strong>，最后实际生成图像的坐标系</li>
                            </ul>
                        </div>
                    </div>
                    <p class="fragment"><strong>映射的本质</strong>是，找到一个函数$f$，为三维模型表面上的<strong>每一个点$P(x,y,z)$</strong>，都能指定一个二维纹理图像上的<strong>对应点$T(u,v)$</strong>，即有:</p>
                    <p class="fragment">
                    $$
                    f(x,y,z)=(u,v)
                    $$</p>
                    <p class="fragment"><strong>拓扑学上的挑战</strong>在于，将一个封闭的三维物体的表面，在不产生任何<strong>撕裂</strong>或<strong>拉伸</strong>的情况下，完全展平成二维的矩形</p>
                </section>
                <section>
                    <h3>纹理映射坐标系</h3>
                    <img class="fragment" src="../../images/cg/chap06/ch06-texcoortrans.png" alt="texcoordinate transform" style="width:70%;">
                </section>
            </section>
            <section>
                <section>
                    <h3>建立映射的两种方案</h3>
                    <ul>
                        <li class="fragment"><strong>美术工作流(Artistic)</strong>：手动“剪开”模型，定义接缝，然后像摊开兽皮一样将其展平，即<strong>UV展开(UV Unwrapping)</strong></li>
                        <li class="fragment"><strong>程序化计算(Procedural)</strong>：用<strong>数学公式</strong>计算映射关系</li>
                    </ul>
                </section>
                <section>
                    <h3>美术工作流(UV Unwrapping)</h3>
                    <p class="fragment">对于复杂模型，无法完全用数学公式建立映射，需要三维建模专业人员介入</p>
                    <div class="two-column">
                        <div>
                        <ul>
                            <li class="fragment"><strong>定义接缝(Seams)</strong>，像裁缝一样，决定在哪里“剪开”三维网格</li>
                            <li class="fragment"><strong>展开(Unwrap)</strong>，使用算法将剪开的一块块内容“孤岛”(Islands)展平到二维UV空间</li>
                            <li class="fragment"><strong>打包(Pack)</strong>，调整这些“孤岛”的位置和大小，使它们尽可能高效地填满$[0,1]\times[0,1]$的纹理空间</li>
                        </ul>
                        <p class="fragment">计算出最终的$(u,v)$坐标后，<strong>永久存储</strong>在模型的VBO中</p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-monkey-uv-unwrapping.jpg" alt="UV Unwrapping" style="width:100%;border:2px solid #ccc;border-radius:8px;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>程序化映射(Procedural)</h3>
                    <div class="two-column">
                        <div>
                            <p class="fragment">对于简单的几何体，可以找到映射关系，将纹理坐标上的一个点，对应到最终成像图像上的位置，该映射关系可表示成</p>
                    <p class="fragment">
                        $$
                        \begin{cases}
                        x=x(s,t)\\
                        y=y(s,t)\\
                        z=z(s,t)
                        \end{cases}
                        $$
                    </p>
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-texcoordmapfunc.png" alt="tex map" style="width:100%;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>建立映射</h3>
                    <p class="fragment">求解映射问题，可以从两方面考虑：</p>
                    <ul>
                        <li class="fragment"><strong>正向映射(Forward Mapping)</strong>：即给定纹理图像上的一个像素，有对应的纹理坐标$(u,v)$出发，如何找到在三维空间中对应的点$(x,y,z)$</li>
                        <li class="fragment"><strong>反向映射(Backward Mapping)</strong>：给定三维空间中的点$(x,y,z)$，如何计算出对应的纹理图像上对应点的坐标$(u,v)$，即找到映射函数，满足
                        $$
                        \begin{cases}
                        u=u(x,y,z)\\
                        v=v(x,y,z)
                        \end{cases}
                        $$
                        但一般很难直接找到这样的映射函数，为方便计算，可采用两步映射法
                        </li>
                    </ul>
                </section>
                <section>
                    <h3>两步映射法</h3>
                    <p class="fragment">两步映射法，先将三维空间中的点$(x,y,z)$映射到参数空间$(s,t)$，再将参数空间$(s,t)$映射到纹理空间$(u,v)$，即有：</p>
                    <div class="two-column">
                        <div>
                        <p class="fragment">
                        $$
                        \begin{cases}
                        s=s(x,y,z)\\
                        t=t(x,y,z)
                        \end{cases}
                        $$
                        </p>
                        </div>
                        <div>
                        <p class="fragment">
                        $$
                        \begin{cases}
                        u=u(s,t)\\
                        v=v(s,t)
                        \end{cases}
                        $$
                    </p>
                        </div>
                    </div>
                        <p class="fragment">
                        这种方法的关键在于，如何定义参数空间$(s,t)$，以及如何建立从三维空间$(x,y,z)$到参数空间$(s,t)$的映射关系。常见的参数空间定义方法有：</p>
                    <ul>
                        <li class="fragment"><strong>平面映射(Planar Mapping)</strong>：将参数空间定义为一个平面，适用于平面或近似平面的物体</li>
                        <li class="fragment"><strong>立方体映射(Cubic Mapping)</strong>：将参数空间定义为一个立方体，适用于立方体或近似立方体的物体</li>
                        <li class="fragment"><strong>球面映射(Spherical Mapping)</strong>   ：将参数空间定义为一个球面，适用于球体或近似球体的物体</li>
                        <li class="fragment"><strong>圆柱映射(Cylindrical Mapping)</strong>：将参数空间定义为一个圆柱面，适用于圆柱体或近似圆柱体的物体</li>
                    </ul>
                </section>
                <section>
                    <h3>映射到圆柱</h3>
                    <div class="two-column">
                        <div>
                            <p class="fragment">假设一个圆柱半径为$r$，高度为$h$，如果用参数$(u,v)$表示圆柱体上一点，则其对应点坐标$(x,y,z)$可定义为：</p>
                            <p class="fragment">
                        $$
                        \begin{cases}
                        x=r\cos{2\pi u}\\
                        y=vh\\
                        z=r\sin{2\pi u}
                        \end{cases}
                        $$
                        </p>
                        <p class="fragment">即完成了从图像坐标$(u,v)$到圆柱体表面一点$P(x,y,z)$的映射</p>
                        <p class="fragment">再将纹理空间$(s,t)$映射到参数空间$(u,v)$，则有：</p>
                        <p class="fragment">
                        $$
                        \begin{cases}
                        s=u\\
                        t=v
                        \end{cases}
                        $$
                        </p>
                        <p class="fragment">这样，就实现了从纹理空间$(s,t)$到三维空间$(x,y,z)$的映射</p>
                        </div>
                        <div class="fragment">
                            <img src="../../images/cg/chap06/ch06-intermediate-cylinder.png" alt="Cylindrical Mapping" style="height:50%;">
                            <img src="../../images/cg/chap06/ch06-intermediate-cylinder-result.png" alt="cylindrical mapping result" style="height:50%;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>映射到圆柱</h3>
                    <p class="fragment">反向映射时，给定圆柱体上一点$P(x,y,z)$，如何计算出对应的纹理坐标$(u,v)$？</p>
                    <p class="fragment">假设圆柱沿$Y$轴放置，半径为$r$，高度$h$，从$y_{min}$到$y_{max}$</p>
                    <p class="fragment"><strong>目标：</strong> $f(x, y, z) = (u, v)$</p>
                    <div class="fragment">
                        <p class="fragment">1. <strong>V坐标(高度):</strong>是$y$坐标的归一化，有</p>
                        <p class="fragment">
                        $$v=\frac{y-y_{min}}{y_{max}-y_{min}}=\frac{y-y_{min}}{h}$$
                        </p>
                    <p class="fragment">2. <strong>U坐标(环绕):</strong>需要$P$点绕$Y$轴的角度 $\theta$</p>
                    <p class="fragment">
                    $$\theta = atan2(z, x)$$
                    </p>
                    <p class="fragment">3. <strong>归一化 U:</strong> $atan2$ 返回值在 $[-\pi, \pi]$。我们需要将其映射到 $[0, 1]$。</p>
                    <p class="fragment">
                    $$u = \frac{\theta + \pi}{2\pi}$$
                    </p>
                    </div>
                    <p class="fragment"><a href="./AppDemos/cylindral_texture_mapping.html" target="_blank">圆柱映射Demo</a></p>
                </section>
                <section>
                    <h3>映射到球体</h3>
                    <div class="two-column">
                        <div>
                            <p class="fragment">假设一个球体半径为$r$，如果用参数$(u,v)$表示球体上一点，则其对应点坐标$(x,y,z)$可定义为：</p>
                            <p class="fragment">
                        $$
                        \begin{cases}
                        x=r\sin{(\pi v)}\cos{(2\pi u)}\\
                        y=r\sin{(\pi v)}\sin{(2\pi u)}\\
                        z=r\cos{(\pi v)}
                        \end{cases}
                        $$
                        </p>
                        <p class="fragment">即完成了从图像坐标$(u,v)$到球体表面一点$P(x,y,z)$的映射</p>
                        <p class="fragment">再将纹理空间$(s,t)$映射到参数空间$(u,v)$，则有：</p>
                        <p class="fragment">
                        $$
                        \begin{cases}
                        s=u\\
                        t=v
                        \end{cases}
                        $$
                        </p>
                        <p class="fragment">这样，就实现了从纹理空间$(s,t)$到三维空间$(x,y,z)$的映射。但在映射过程中，需考虑到球体存在形变。球体一般用于环境映射</p>
                        </div>
                        <div class="fragment">
                            <img src="../../images/cg/chap06/ch06-intermediate-sphere.png" alt="Cylindrical Mapping" style="width:40%;">
                            <img src="../../images/cg/chap06/ch06-intermediate-sphere-result.png" alt="cylindrical mapping result" style="width:60%;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>映射到球体</h3>
                    <p><a href="./AppDemos/spherical_coordinates_demo.html" target="_blank">球面坐标系</a></p>
                    <iframe src="./AppDemos/spherical_coordinates_demo.html" width="100%" height="600px" style="border: 1px solid #ccc; border-radius: 8px;"></iframe>
                </section>
                <section>
                    <h3>映射到球体</h3>
                    <p class="fragment" style="font-size:20pt">反向映射时，给定球体上一点$P(x,y,z)$，如何计算出对应的纹理坐标$(u,v)$？</p>
                    <p class="fragment" style="font-size:20pt">假设球体中心在原点，半径为$r$，需要从球面上一点$(x,y,z)$反求经度$\lambda$和纬度$\phi$</p>
                    <p class="fragment" style="font-size:20pt"><strong>目标：</strong> $f(x, y, z) = (u, v)$</p>
                    <div class="fragment">
                        <p class="fragment" style="font-size:20pt">1. <strong>U坐标(经度)：</strong>与圆柱映射完全相同，是$P$点在$XOZ$平面上的投影角度，有</p>
                        <p class="fragment" style="font-size:20pt">
                        $$\lambda = atan2(z,x)$$
                        $$u=\frac{\lambda + \pi}{2\pi}$$
                        </p>
                    <p class="fragment" style="font-size:20pt">2. <strong>V坐标(纬度)：</strong>需要$P$点与$XOZ$平面的夹角</p>
                    <p class="fragment" style="font-size:20pt">
                    $$\phi=\arcsin{\frac{y}{r}}$$
                    </p>
                    <p class="fragment" style="font-size:20pt">3. <strong>归一化：</strong>$\arcsin$返回值在$[-\pi/2, \pi/2]$之间，因此需要将其映射到$[-1,1]$之间</p>
                    <p class="fragment" style="font-size:20pt">
                    $$v=\frac{\phi + \pi/2}{\pi}$$
                    </p>
                    </div>
                </section>
                <section>
                    <h3>映射到球体的问题</h3>
                    <p class="fragment">用前面计算的映射函数求解，当点在北极点时，$P=(0, r, 0)$</p>
                    <ul>
                        <li class="fragment">U坐标为，$u=(atan2(0,0)+\pi)/(2\pi)$，而$atan2(0,0)$是<strong>未定义的</strong></li>
                        <li class="fragment">V坐标为，$v=(arcsin(r/r)+\pi/2)/\pi=(\pi/2+\pi/2)/\pi=1$，即所有的北极点都映射到纹理的<strong>顶边</strong></li>
                    </ul>
                    <p class="fragment" style="font-size:20pt">在拓扑学上，在球面上，北极点是一个<strong>单独的点</strong>，但在二维纹理上，被映射成了<strong>一整条边</strong>($v=1$)，这也是地图上格陵兰岛和南极洲被无限拉伸的原因，也是球面映射的固有的缺陷</p>
                    <div class="two-column">
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-Mercator_projection_Square.JPG" alt="Spherical Mapping Pole Issue" style="width:60%;">
                        </div>
                        <div>
                            <img class="fragment" src="../../images/cg/chap06/ch06-Tissot_indicatrix_world_map_equirectangular_proj.svg.png" alt="Spherical Mapping Pole UV Issue" style="width:100%;">
                        </div>
                    </div>
                </section>
                <section>
                    <h3>映射到立方体</h3>
                    <p class="fragment">也可通过简单的正投影将纹理直接映射到立方体盒子表面，可用于环境映射计算</p>
                    <img class="fragment" src="../../images/cg/chap06/ch06-boxmap.png" alt="Cubemap Texture" style="width:60%;">
                </section>
                <section>
                    <h3>中间形体坐标计算</h3>
                    <img class="fragment" src="../../images/cg/chap06/ch06-texmap-inter-coord.png" alt="tex map summary" style="width:70%;">
                </section>
            </section>
            <section>
                <section>
                    <h3>从中间形体到实际形体</h3>
                    <p class="fragment">建立从中间形体到实际形体的映射，目标是将一般形体$M$上的点$P_M$映射到中间形体$S$上的点$P_S$，即$P_S=g(P_M)$</p>
                    <ul>
                        <li class="fragment">中间形体法线投影，将点$P_M$沿物体表面方向映射到其正对的中间形体表面上的点。或者，对中间形体表面上的每一个点，沿法线方向找到对应实际形体上的对应点</li>
                        <li class="fragment">中间形体中心投影，这是<strong>最常用的方法</strong>，将$P_M$拉伸到中间形体上，方向由中间形体的中心点决定 </li>
                    </ul>
                    <img class="fragment" src="../../images/cg/chap06/ch06-secondmap.png" alt="second mapping" style="width:60%;">
                </section>
                <section>
                    <h3>法线投影</h3>
                    <p class="fragment">对实际形体$M$表面上的点$P_M$，沿其法线方向，找到与中间形体$S$表面相交的点$P_S$</p>
                    <div class="two-column">
                        <div>
                            <ul>
                            <li class="fragment">对点$P_M$，计算其法线$N_M$</li>
                            <li class="fragment">定义射线方程$R(t)=P_M+t N_M$</li>
                            <li class="fragment">计算$R(t)$与中间形体$S$的交点$P_S$</li>
                            <li class="fragment">即有$g(P_M)=P_S$</li>
                        </ul>
                        </div>
                        <div>
                            <ul>
                                <li class="fragment"><strong>优点:</strong> 理论上能更“贴合”模型的凹凸细节。</li>
                                <li class="fragment"><strong>缺点:</strong>
                                    <ul>
                                        <li class="fragment">计算 $g$ 非常昂贵（需要射线-形体求交）。</li>
                                        <li class="fragment">如果 $N_M$ 不指向 $S$（例如在凹陷处），则映射失败。</li>
                                        <li class="fragment">如果 $M$ 是凹形 (concave)，多个 $P_M$ 可能映射到同一个 $P_S$。</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>中间形体中心投影</h3>
                    <p class="fragment">对实际形体$M$表面上的点$P_M$，沿中心线方向，将其投射到中间形体$S$表面上对应的点$P_S$，中心线方向由$S$决定，前面的球体推导过程正是利用了该方法</p>
                    <div class="two-column">
                        <div>
                            <p class="fragment">以$S$为球体为例</p>
                            <ul>
                                <li class="fragment">对于 $M$ 上的点 $P_M$，计算其相对于 $S$ 中心的向量 $V = P_M - S_{center}$。</li>
                                <li class="fragment">这个 $V$ 的方向，正是$S$在其表面“对应点”的法线方向$N_S$。</li>
                                <li class="fragment">将$P_M$沿此方向“拉”到$S$的表面，即对其归一化</li>
                                <li class="fragment">$P_S = g(P_M) = normalize(V) \cdot S_{radius} + S_{center}$</li>
                            </ul>
                        </div>
                        <div>
                            <ul>
                            <li class="fragment"><strong>优点:</strong>
                                <ul>
                                    <li class="fragment">计算 $g$ 极其简单（例如，球体 $g$ 只是 $normalize(P_M)$）</li>
                                    <li class="fragment">总是能找到映射（除非 $P_M$在$S$中心）</li>
                                </ul>
                            </li>
                            <li class="fragment"><strong>缺点:</strong> 
                                <ul>
                                    <li class="fragment">会产生拉伸（如地图）</li>
                                </ul>
                            </li>
                            <li class="fragment"><strong>用途:</strong>是<strong>球面映射</strong> 和 <strong>圆柱映射</strong> 的基础</li>
                        </ul>
                        </div>
                    </div>
                </section>
                <section>
                    <h3>纹理映射交互式Demo</h3>
                    <iframe src="./AppDemos/uv-mapping-demo.html"  width="100%" height="800px" style="border: 1px solid #ccc; border-radius: 8px;"></iframe>
                </section>
            </section>
            <section>
                <h3>课堂测试</h3>
                <p>你正在为一个场景建模。请为左侧的物体选择最合适的 <strong>纹理映射</strong> 方式：</p>
                <div class="two-column">
                    <div class="col">
                        <h4>物体</h4>
                        <ol>
                            <li>一面平整的砖墙</li>
                            <li>一根圆柱形的大理石柱子</li>
                            <li>一个太阳系的行星模型</li>
                        </ol>
                    </div>
                    <div class="col">
                        <h4>映射方法</h4>
                        <ul>
                            <li>A. 球面映射 (Spherical)</li>
                            <li>B. 平面映射 (Planar)</li>
                            <li>C. 柱面映射 (Cylindrical)</li>
                        </ul>
                    </div>
                </div>
                <div class="fragment" data-fragment-index="1" style="background: #2b2b2b; padding: 10px; border-radius: 5px; margin-top: 30px; text-align: center;">
                    <p style="color: white; margin-bottom: 5px;"><strong>答案: 1 ➔ B, 2 ➔ C, 3 ➔ A</strong></p>
                </div>
            </section>
            <section>
                <h3>课堂总结</h3>
                <ul>
                    <li>纹理映射是将二维图像“粘贴”到三维物体表面，以增强视觉真实感的技术</li>
                    <li>纹理坐标$(u,v)$定义了三维物体表面点与二维纹理图像点之间的对应关系</li>
                    <li>建立映射关系的方法包括手动UV展开和通过数学公式计算两种形式</li>
                    <li>常见的中间形体定义方法有平面映射、立方体映射、球面映射和圆柱映射</li>
                    <li>从中间形体到实际形体的映射方法包括法线投影和中间形体中心投影</li>
                </ul>
            </section>
        </div>
    </div>

<script src="../../../dist/reveal.js"></script>
<script src="../../../plugin/zoom/zoom.js"></script>
<script src="../../../plugin/notes/notes.js"></script>
<script src="../../../plugin/search/search.js"></script>
<script src="../../../plugin/markdown/markdown.js"></script>
<script src="../../../plugin/highlight/highlight.js"></script>
<script src="../../../plugin/math/math.js"></script>
<script>
Reveal.initialize({
	bash: true,
	// display controls in the bottom right corner
    controls: true,

    hash: true,

    // display a presentation progress bar
    progress: true,

    // set default timing of 2 minutes per slides
    defaultTiming: 120,

    // Display the page number of the current slides
    slideNumber: true,

    // Push each slide change to the browser history
    history: false,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: true,

    // Enable touch navigation on devices with touch input
    touch: true,

    // Loop the presentation
    loop: false,

    // Change teh presentation direction to be RTL
    rtl: false,

    // Randomizes the order of slides each time the presentation loads
    shuffle: false,

    // Turns fragments on and off globally
    fragment: true,

    // Flags if the presentation is running in an embedded mode,
    // i.e. contained within a limited portion of the screen
    embedded: false,

    // Flags if we should show a help overlay when the questionmark key is pressed
    help: true,

    // Flags if speaker notes should be visible to all viewers
    showNotes: false,

    // Global override for autoplaying embedded media( video/audio/iframe)
    // - null: media will only autoplay if data-autopay is present
    // - true: all media will autoplay, regradless of individual setting
    // - false: no media will autoplay, regardless of individual setting
    autoPlayMedia: null,

    // Number of milliseconds between automatically proceeding to the next slide, 
    //disabled when set to 0, this value can be overwritten by
    // using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Stop auto-sliding after user input
    autoSlideStoppable: true,

    // Use this method for navigation when auto-sliding
    autoSlideMethod: Reveal.navigateNext,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Hides the address bar on mobile devices
    hideAddressBar: true,

    // Opens links in an iframe preview overlay
    previewLinks: false,

    // Transition style
    transition: 'slide', // none/fade/slide/convex/concave/zoom

    // Transition speed
    transitionSpeed: 'default', // default/fast/slow

    // Transition style for full page slide backgrounds
    backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom

    // Number of slides away from the current that are visible
    viewDistance: 3,

    // Parallax background image
    parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakin-static/reveal-js/reveal-parallax-1.jpg'"

    // Parallax background size
    parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

    // Number of pixels to move the parallax background per slide
    // - calculated automatically unless specified
    // - set to 0 to disable movement along an axis
    parallaxBackgroundHorizontal: null,
    parallaxBackgroundVertical: null,

    // The display mode that will be used to show slides
    display: 'block',

    // print to pdf while no slide grows to more than one printed page
    pdfMaxPagesPerSlide: 1,

    // presentation
    width: '100%',
    height: '100%',

    margin: 0.1,

    minScale: 0.2,
    maxScale: 1.5, 
    plugins: [RevealMath.KaTeX, RevealHighlight, RevealNotes],
    })
</script>
</body>
</html>