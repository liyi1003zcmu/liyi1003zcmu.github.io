<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å…¨å±€å…‰ç…§ vs. å±€éƒ¨å…‰ç…§</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/sky.css" id="theme">
    <style>
        .container-flex { display: flex; justify-content: space-around; align-items: center; gap: 20px; }
        .col-2 { flex-basis: 48%; text-align: center; }
        .comparison-box { border: 2px solid #ddd; border-radius: 10px; padding: 15px; }
        .interactive-title { font-size: 0.8em; margin-bottom: 10px; font-weight: bold; }

        /* Interactive Scene Styles */
        .interactive-scene-container {
            width: 400px;
            height: 300px;
            margin: 10px auto;
            background-color: #f0f0f0;
            border-radius: 15px;
            padding: 20px;
        }
        .scene {
            position: relative;
            width: 100%;
            height: 100%;
            background: #dcdcdc;
            perspective: 800px;
        }
        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: #bdbdbd;
            transform: rotateX(70deg);
            transition: background 0.5s ease;
        }
        .wall-left {
            position: absolute;
            left: -150px;
            bottom: 0;
            width: 300px;
            height: 100%;
            background: #ff8a80; /* Red Wall */
            transform: rotateY(-60deg) translateZ(-150px);
        }
         .sphere {
            position: absolute;
            bottom: 60%;
            left: 50%;
            width: 100px;
            height: 100px;
            margin-left: -50px;
            margin-bottom: -50px;
            border-radius: 50%;
            background: radial-gradient(circle at 65% 35%, #ffffff, #81c784); /* Green Sphere */
            transform-style: preserve-3d;
            transform: translateZ(50px);
            box-shadow: 20px 20px 20px rgba(0,0,0,0.5);
            transition: box-shadow 0.5s ease;
        }
        /* Global Illumination Effects */
        .scene.global .floor {
            background: radial-gradient(ellipse at 30% 80%, rgba(255, 138, 128, 0.4) 0%, transparent 50%), #bdbdbd;
        }
        .scene.global .sphere {
             box-shadow: 20px 20px 40px rgba(0,0,0,0.3); /* Softer shadow */
        }
        .controls { margin-top: 10px; }
        .controls button { font-size: 0.8em; padding: 10px 15px; margin: 0 10px; cursor: pointer; }

        /* Ray Tracing Viz Styles */
        #ray-tracing-canvas {
            border: 1px solid black;
            background-color: #eef2f7;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>è®¡ç®—æœºå›¾å½¢å­¦ Â· é«˜çº§æ¸²æŸ“</h2>
                <h3>å…¨å±€å…‰ç…§ vs. å±€éƒ¨å…‰ç…§</h3>
                <p>æ¢ç´¢å…‰çº¿å¦‚ä½•â€œå‘¨æ¸¸â€ä¸–ç•Œ</p>
            </section>
            
            <section>
                <h3>æˆ‘ä»¬å·²çŸ¥çš„å…‰ç…§...</h3>
                <p>ä½¿ç”¨ <strong>å±€éƒ¨å…‰ç…§ (Local Illumination)</strong> æ¨¡å‹ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸é”™çš„æ•ˆæœã€‚</p>
                <div class="container-flex">
                    <div class="col-2">
                        <!-- Image Generation Prompt: A simple 3D scene (e.g., a few spheres and cubes on a plane) rendered with a basic local illumination model like Phong. It should have direct lighting and hard, sharp-edged shadows. No indirect light. -->
                        <img src="https://i.imgur.com/vHq0A6M.png" height="300">
                        <p>å…‰ç…§æ¥è‡ªå…‰æºï¼Œé˜´å½±æ˜¯â€œæ­»é»‘â€çš„ã€‚</p>
                    </div>
                    <div class="col-2">
                        <p class="fragment">ä½†çœŸå®ä¸–ç•Œæ˜¯è¿™æ ·çš„...</p>
                         <!-- Image Generation Prompt: The exact same 3D scene, but rendered with a global illumination model. Shadows are soft and realistic, and there is visible color bleeding (e.g., a red sphere casting a faint red light onto the white plane next to it). -->
                        <img class="fragment" src="https://i.imgur.com/Kz8F2tP.png" height="300">
                        <p class="fragment">å…‰çº¿ä¼šåå¼¹ï¼Œç‰©ä½“ä¼šç›¸äº’ç…§äº®ã€‚</p>
                    </div>
                </div>
            </section>

            <section>
                <h3>æ ¸å¿ƒåŒºåˆ«: å…‰çº¿çš„è·¯å¾„</h3>
                <div class="container-flex">
                    <div class="col-2 comparison-box">
                        <h4>å±€éƒ¨å…‰ç…§ (Local Illumination)</h4>
                        <p>åªè€ƒè™‘å…‰çº¿ä»<strong>å…‰æº</strong>ç›´æ¥åˆ°<strong>ç‰©ä½“è¡¨é¢</strong>çš„è·¯å¾„ã€‚</p>
                        <p style="font-size: 1.5em; font-family: monospace;">å…‰æº &rarr; è¡¨é¢ &rarr; çœ¼ç›</p>
                        <p class="fragment"><strong>ç‰¹ç‚¹:</strong> è®¡ç®—å¿«ï¼Œé€‚åˆå®æ—¶åº”ç”¨ï¼ˆå¦‚å¤§å¤šæ•°æ¸¸æˆï¼‰ï¼Œä½†å¿½ç•¥äº†é—´æ¥å…‰ç…§ã€‚</p>
                    </div>
                     <div class="col-2 comparison-box fragment">
                        <h4>å…¨å±€å…‰ç…§ (Global Illumination)</h4>
                        <p>æ¨¡æ‹Ÿå…‰çº¿åœ¨åœºæ™¯ä¸­<strong>æ‰€æœ‰å¯èƒ½çš„åå¼¹è·¯å¾„</strong>ã€‚</p>
                        <p style="font-size: 1.5em; font-family: monospace;">å…‰æº &rarr; è¡¨é¢ &rarr; è¡¨é¢ &rarr; ... &rarr; çœ¼ç›</p>
                        <p class="fragment"><strong>ç‰¹ç‚¹:</strong> æ•ˆæœæå…¶é€¼çœŸï¼Œèƒ½äº§ç”Ÿè½¯é˜´å½±ã€é¢œè‰²æº¢å‡ºç­‰ï¼Œä½†è®¡ç®—é‡å·¨å¤§ã€‚</p>
                    </div>
                </div>
            </section>
            
            <section>
                <h3>äº¤äº’å¼ç¤ºä¾‹ï¼šå…‰ç…§æ•ˆæœå¯¹æ¯”</h3>
                 <!-- Interactive App Prompt:
                Title: Interactive Global vs. Local Illumination
                Description: Create a simple 3D-like scene using HTML divs and CSS transforms. The scene contains a floor, a red left wall, and a green sphere in the middle with a hard shadow. Provide two buttons: "Local Illumination" and "Global Illumination". When "Local" is active, the scene is as described. When the "Global Illumination" button is clicked, animate two changes: 1. The hard shadow under the sphere smoothly transitions to a softer, more diffuse shadow. 2. A faint red glow (color bleeding) appears on the floor near the red wall. This demonstrates the key visual differences interactively.
                -->
                <p class="interactive-title">ç‚¹å‡»æŒ‰é’®ï¼Œè§‚å¯Ÿå…‰ç…§æ•ˆæœçš„å˜åŒ–</p>
                <div class="interactive-scene-container">
                    <div class="scene" id="comparison-scene">
                        <div class="floor"></div>
                        <div class="wall-left"></div>
                        <div class="sphere"></div>
                    </div>
                    <div class="controls">
                        <button id="btn-local">å±€éƒ¨å…‰ç…§ (Local)</button>
                        <button id="btn-global">å…¨å±€å…‰ç…§ (Global)</button>
                    </div>
                </div>
                <p class="fragment">è¯·æ³¨æ„å…¨å±€å…‰ç…§ä¸‹çš„<span style="color:red;">é¢œè‰²æº¢å‡º</span>å’Œ<span style="color:blue;">æŸ”å’Œé˜´å½±</span>ã€‚</p>
            </section>
            
            <section>
                <h3>å…¨å±€å…‰ç…§çš„æ¸²æŸ“æ–¹æ³•</h3>
                <p>ä¸»è¦æœ‰ä¸¤ç§ç»å…¸æŠ€æœ¯æ¥å®ç°å…¨å±€å…‰ç…§ï¼š</p>
                <div class="container-flex">
                    <div class="col-2 fragment">
                        <h5>å…‰çº¿è¿½è¸ª (Ray Tracing)</h5>
                        <!-- Image URL: a diagram illustrating ray tracing from https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Ray_trace_diagram.svg/1200px-Ray_trace_diagram.svg.png -->
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Ray_trace_diagram.svg/1200px-Ray_trace_diagram.svg.png" height="250">
                        <p>ä»ç›¸æœºåå‘è¿½è¸ªå…‰çº¿è·¯å¾„ã€‚<br>æ“…é•¿å¤„ç†<span style="color:blue;">é•œé¢åå°„ã€æŠ˜å°„ã€ç²¾ç¡®é˜´å½±</span>ã€‚</p>
                    </div>
                    <div class="col-2 fragment">
                        <h5>è¾å°„åº¦ (Radiosity)</h5>
                        <!-- Image URL: a diagram illustrating radiosity from https://accad.osu.edu/research/gose/radiosity/rad_files/image002.gif -->
                        <img src="https://accad.osu.edu/research/gose/radiosity/rad_files/image002.gif" height="250">
                        <p>è®¡ç®—è¡¨é¢ä¹‹é—´çš„å…‰èƒ½ä¼ é€’ã€‚<br>æ“…é•¿å¤„ç†<span style="color:red;">æ¼«åå°„é—´çš„é¢œè‰²æº¢å‡ºã€æŸ”å’Œå…‰ç…§</span>ã€‚</p>
                    </div>
                </div>
            </section>
            
            <section>
                <h3>æ·±å…¥æ¢ç´¢ï¼šå…‰çº¿è¿½è¸ª</h3>
                <p>å…‰çº¿è¿½è¸ªé€šè¿‡æ¨¡æ‹Ÿæ¯ä¸€æ¡å…‰çº¿çš„æ—…ç¨‹æ¥ç¡®å®šåƒç´ çš„é¢œè‰²ã€‚</p>
                <ul>
                    <li class="fragment"><strong>ä¸»å…‰çº¿ (Primary Ray):</strong> ä»ç›¸æœºå‘å‡ºï¼Œç©¿è¿‡åƒç´ ï¼Œå°„å…¥åœºæ™¯ã€‚</li>
                    <li class="fragment"><strong>é˜´å½±å…‰çº¿ (Shadow Ray):</strong> ä»äº¤ç‚¹å°„å‘å…‰æºï¼Œæ£€æµ‹æ˜¯å¦è¢«é®æŒ¡ã€‚</li>
                    <li class="fragment"><strong>åå°„/æŠ˜å°„å…‰çº¿ (Secondary Rays):</strong> å¦‚æœè¡¨é¢æ˜¯åå°„/æŠ˜å°„æè´¨ï¼Œå…‰çº¿ä¼šç»§ç»­å¼¹è·³ã€‚</li>
                </ul>
                <p class="fragment">è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªäº¤äº’å¼ç¤ºä¾‹æ¥äº²æ‰‹â€œè¿½è¸ªâ€å…‰çº¿ï¼</p>
            </section>
            
            <section>
                 <h3>äº¤äº’å¼ç¤ºä¾‹ï¼š2Då…‰çº¿è¿½è¸ªæ¨¡æ‹Ÿå™¨</h3>
                <!-- Interactive App Prompt:
                Title: Interactive 2D Ray Tracer
                Description: Create a 2D visualization on an HTML canvas. The scene includes a camera icon on the left, a light source icon on the top, a blue diffuse sphere, a silver reflective sphere, and a floor. A 'screen' line is shown in front of the camera. The user can click anywhere on the canvas. When clicked, a primary ray is animated from the camera towards the click point.
                - If it hits the blue sphere, it stops. A dashed shadow ray is then cast towards the light. If it hits another object, a "SHADOW" text appears; otherwise, a "LIT" text appears.
                - If it hits the silver sphere, it reflects. A secondary reflection ray is cast.
                - If it hits the floor, it stops and casts a shadow ray.
                - A "Reset" button clears all drawn rays.
                This visually demonstrates the fundamental algorithm of ray tracing.
                -->
                <p class="interactive-title">åœ¨ç”»å¸ƒä¸Šç‚¹å‡»ï¼Œä»ç›¸æœºå‘å°„å…‰çº¿æ¥æ¢ç´¢åœºæ™¯</p>
                <div class="interactive-scene-container" style="height: auto; text-align: center;">
                    <canvas id="ray-tracing-canvas" width="580" height="350"></canvas>
                    <div class="controls">
                        <button id="btn-reset-rays">é‡ç½® (Reset)</button>
                    </div>
                </div>
            </section>

            <section>
                <h3>æ€»ç»“</h3>
                <ul>
                    <li class="fragment"><strong>å±€éƒ¨å…‰ç…§</strong> å¿«é€Ÿä½†ç®€å•ï¼Œåªè€ƒè™‘ç›´æ¥å…‰ã€‚</li>
                    <li class="fragment"><strong>å…¨å±€å…‰ç…§</strong> é€¼çœŸä½†æ¶ˆè€—èµ„æºï¼Œæ¨¡æ‹Ÿå…‰çš„åå¼¹ã€‚</li>
                    <li class="fragment"><strong>å…‰çº¿è¿½è¸ª</strong> å’Œ <strong>è¾å°„åº¦</strong> æ˜¯å®ç°å…¨å±€å…‰ç…§çš„å¼ºå¤§æŠ€æœ¯ã€‚</li>
                    <li class="fragment">ç°ä»£å›¾å½¢å­¦æ­£åœ¨åŠªåŠ›å°†å…¨å±€å…‰ç…§æŠ€æœ¯ï¼ˆå¦‚å®æ—¶å…‰çº¿è¿½è¸ªï¼‰å¸¦å…¥æ›´å¤šå®æ—¶åº”ç”¨ä¸­ã€‚</li>
                </ul>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            plugins: [ RevealNotes ],
            slideNumber: true,
        });

        // Interactive Scene Logic
        const scene = document.getElementById('comparison-scene');
        const btnLocal = document.getElementById('btn-local');
        const btnGlobal = document.getElementById('btn-global');

        if (scene) {
            btnLocal.onclick = () => scene.classList.remove('global');
            btnGlobal.onclick = () => scene.classList.add('global');
        }

        // Interactive Ray Tracing Logic
        const canvas = document.getElementById('ray-tracing-canvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            const btnReset = document.getElementById('btn-reset-rays');
            
            const camera = { x: 50, y: canvas.height / 2 };
            const light = { x: canvas.width / 2, y: 30, size: 15 };
            const sceneObjects = [
                { type: 'sphere', x: 250, y: 200, radius: 50, color: '#42a5f5', material: 'diffuse' }, // Blue diffuse
                { type: 'sphere', x: 450, y: 150, radius: 40, color: '#bdbdbd', material: 'reflective' }, // Silver reflective
                { type: 'plane', y: canvas.height - 30, color: '#78909c' }
            ];

            function drawScene() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw Camera (Eye icon)
                ctx.fillStyle = '#424242';
                ctx.font = '30px sans-serif';
                ctx.fillText('ğŸ‘ï¸', camera.x - 20, camera.y + 10);

                // Draw Light (Sun icon)
                ctx.fillStyle = '#FFEB3B';
                ctx.font = '30px sans-serif';
                ctx.fillText('â˜€ï¸', light.x - light.size, light.y + light.size);

                // Draw Objects
                sceneObjects.forEach(obj => {
                    if (obj.type === 'sphere') {
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        ctx.fillStyle = obj.color;
                        ctx.fill();
                        // fake highlight
                        ctx.beginPath();
                        ctx.arc(obj.x-10, obj.y-10, obj.radius/4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.fill();
                    } else if (obj.type === 'plane') {
                        ctx.fillStyle = obj.color;
                        ctx.fillRect(0, obj.y, canvas.width, canvas.height - obj.y);
                    }
                });
            }

            function intersect(ray, objects) {
                let closestHit = null;
                let minDistance = Infinity;

                objects.forEach(obj => {
                    if (obj.type === 'sphere') {
                        const oc = { x: ray.origin.x - obj.x, y: ray.origin.y - obj.y };
                        const a = ray.dir.x * ray.dir.x + ray.dir.y * ray.dir.y;
                        const b = 2.0 * (oc.x * ray.dir.x + oc.y * ray.dir.y);
                        const c = (oc.x * oc.x + oc.y * oc.y) - obj.radius * obj.radius;
                        const discriminant = b * b - 4 * a * c;
                        if (discriminant >= 0) {
                            const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);
                            if (t > 0.001 && t < minDistance) {
                                minDistance = t;
                                closestHit = {
                                    t: t,
                                    point: { x: ray.origin.x + t * ray.dir.x, y: ray.origin.y + t * ray.dir.y },
                                    object: obj,
                                    normal: { x: (ray.origin.x + t * ray.dir.x - obj.x) / obj.radius, y: (ray.origin.y + t * ray.dir.y - obj.y) / obj.radius }
                                };
                            }
                        }
                    } else if (obj.type === 'plane') {
                        if(ray.dir.y > 0) { // moving downwards
                           const t = (obj.y - ray.origin.y) / ray.dir.y;
                           if(t > 0.001 && t < minDistance) {
                                minDistance = t;
                                closestHit = {
                                    t: t,
                                    point: { x: ray.origin.x + t * ray.dir.x, y: ray.origin.y + t * ray.dir.y },
                                    object: obj,
                                    normal: { x: 0, y: -1 }
                                };
                           }
                        }
                    }
                });
                return closestHit;
            }

            function trace(ray) {
                // Draw primary ray
                ctx.beginPath();
                ctx.moveTo(ray.origin.x, ray.origin.y);
                const hit = intersect(ray, sceneObjects);
                
                if (hit) {
                    ctx.lineTo(hit.point.x, hit.point.y);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Shadow ray
                    const shadowRayDir = { x: light.x - hit.point.x, y: light.y - hit.point.y };
                    const shadowRayDist = Math.sqrt(shadowRayDir.x * shadowRayDir.x + shadowRayDir.y * shadowRayDir.y);
                    shadowRayDir.x /= shadowRayDist;
                    shadowRayDir.y /= shadowRayDist;
                    const shadowRay = { origin: hit.point, dir: shadowRayDir };
                    
                    const shadowHit = intersect(shadowRay, sceneObjects);
                    
                    ctx.beginPath();
                    ctx.moveTo(hit.point.x, hit.point.y);
                    ctx.lineTo(light.x, light.y);
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 1;
                    
                    if (shadowHit && shadowHit.t < shadowRayDist) {
                        ctx.strokeStyle = 'red';
                        ctx.stroke();
                        ctx.fillStyle = 'red';
                        ctx.fillText('é˜´å½± (SHADOW)', hit.point.x + 10, hit.point.y - 10);
                    } else {
                         ctx.strokeStyle = 'orange';
                         ctx.stroke();
                         ctx.fillStyle = 'green';
                         ctx.fillText('ç…§äº® (LIT)', hit.point.x + 10, hit.point.y - 10);
                    }
                    ctx.setLineDash([]);
                    
                    // Reflection ray
                    if (hit.object.material === 'reflective') {
                        const d = ray.dir;
                        const n = hit.normal;
                        const dot = 2 * (d.x * n.x + d.y * n.y);
                        const reflectDir = { x: d.x - dot * n.x, y: d.y - dot * n.y };
                        const reflectRay = { origin: hit.point, dir: reflectDir };
                        
                        ctx.beginPath();
                        ctx.moveTo(reflectRay.origin.x, reflectRay.origin.y);
                        ctx.lineTo(reflectRay.origin.x + reflectRay.dir.x * 300, reflectRay.origin.y + reflectRay.dir.y * 300);
                        ctx.strokeStyle = 'purple';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                } else {
                    ctx.lineTo(ray.origin.x + ray.dir.x * canvas.width, ray.origin.y + ray.dir.y * canvas.width);
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.stroke();
                }
            }

            canvas.addEventListener('click', (e) => {
                drawScene(); // Redraw scene to clear previous rays
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const dir = { x: mouseX - camera.x, y: mouseY - camera.y };
                const mag = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
                dir.x /= mag;
                dir.y /= mag;

                trace({ origin: camera, dir: dir });
            });

            btnReset.onclick = drawScene;

            drawScene();
        }

    </script>
</body>
</html>
