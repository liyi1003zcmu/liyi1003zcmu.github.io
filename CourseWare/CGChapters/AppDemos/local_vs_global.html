<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>全局光照 vs. 局部光照</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/sky.css" id="theme">
    <style>
        .container-flex { display: flex; justify-content: space-around; align-items: center; gap: 20px; }
        .col-2 { flex-basis: 48%; text-align: center; }
        .comparison-box { border: 2px solid #ddd; border-radius: 10px; padding: 15px; }
        .interactive-title { font-size: 0.8em; margin-bottom: 10px; font-weight: bold; }

        /* Interactive Scene Styles */
        .interactive-scene-container {
            width: 400px;
            height: 300px;
            margin: 10px auto;
            background-color: #f0f0f0;
            border-radius: 15px;
            padding: 20px;
        }
        .scene {
            position: relative;
            width: 100%;
            height: 100%;
            background: #dcdcdc;
            perspective: 800px;
        }
        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60%;
            background: #bdbdbd;
            transform: rotateX(70deg);
            transition: background 0.5s ease;
        }
        .wall-left {
            position: absolute;
            left: -150px;
            bottom: 0;
            width: 300px;
            height: 100%;
            background: #ff8a80; /* Red Wall */
            transform: rotateY(-60deg) translateZ(-150px);
        }
         .sphere {
            position: absolute;
            bottom: 60%;
            left: 50%;
            width: 100px;
            height: 100px;
            margin-left: -50px;
            margin-bottom: -50px;
            border-radius: 50%;
            background: radial-gradient(circle at 65% 35%, #ffffff, #81c784); /* Green Sphere */
            transform-style: preserve-3d;
            transform: translateZ(50px);
            box-shadow: 20px 20px 20px rgba(0,0,0,0.5);
            transition: box-shadow 0.5s ease;
        }
        /* Global Illumination Effects */
        .scene.global .floor {
            background: radial-gradient(ellipse at 30% 80%, rgba(255, 138, 128, 0.4) 0%, transparent 50%), #bdbdbd;
        }
        .scene.global .sphere {
             box-shadow: 20px 20px 40px rgba(0,0,0,0.3); /* Softer shadow */
        }
        .controls { margin-top: 10px; }
        .controls button { font-size: 0.8em; padding: 10px 15px; margin: 0 10px; cursor: pointer; }

        /* Ray Tracing Viz Styles */
        #ray-tracing-canvas {
            border: 1px solid black;
            background-color: #eef2f7;
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h2>计算机图形学 · 高级渲染</h2>
                <h3>全局光照 vs. 局部光照</h3>
                <p>探索光线如何“周游”世界</p>
            </section>
            
            <section>
                <h3>我们已知的光照...</h3>
                <p>使用 <strong>局部光照 (Local Illumination)</strong> 模型，我们可以得到不错的效果。</p>
                <div class="container-flex">
                    <div class="col-2">
                        <!-- Image Generation Prompt: A simple 3D scene (e.g., a few spheres and cubes on a plane) rendered with a basic local illumination model like Phong. It should have direct lighting and hard, sharp-edged shadows. No indirect light. -->
                        <img src="https://i.imgur.com/vHq0A6M.png" height="300">
                        <p>光照来自光源，阴影是“死黑”的。</p>
                    </div>
                    <div class="col-2">
                        <p class="fragment">但真实世界是这样的...</p>
                         <!-- Image Generation Prompt: The exact same 3D scene, but rendered with a global illumination model. Shadows are soft and realistic, and there is visible color bleeding (e.g., a red sphere casting a faint red light onto the white plane next to it). -->
                        <img class="fragment" src="https://i.imgur.com/Kz8F2tP.png" height="300">
                        <p class="fragment">光线会反弹，物体会相互照亮。</p>
                    </div>
                </div>
            </section>

            <section>
                <h3>核心区别: 光线的路径</h3>
                <div class="container-flex">
                    <div class="col-2 comparison-box">
                        <h4>局部光照 (Local Illumination)</h4>
                        <p>只考虑光线从<strong>光源</strong>直接到<strong>物体表面</strong>的路径。</p>
                        <p style="font-size: 1.5em; font-family: monospace;">光源 &rarr; 表面 &rarr; 眼睛</p>
                        <p class="fragment"><strong>特点:</strong> 计算快，适合实时应用（如大多数游戏），但忽略了间接光照。</p>
                    </div>
                     <div class="col-2 comparison-box fragment">
                        <h4>全局光照 (Global Illumination)</h4>
                        <p>模拟光线在场景中<strong>所有可能的反弹路径</strong>。</p>
                        <p style="font-size: 1.5em; font-family: monospace;">光源 &rarr; 表面 &rarr; 表面 &rarr; ... &rarr; 眼睛</p>
                        <p class="fragment"><strong>特点:</strong> 效果极其逼真，能产生软阴影、颜色溢出等，但计算量巨大。</p>
                    </div>
                </div>
            </section>
            
            <section>
                <h3>交互式示例：光照效果对比</h3>
                 <!-- Interactive App Prompt:
                Title: Interactive Global vs. Local Illumination
                Description: Create a simple 3D-like scene using HTML divs and CSS transforms. The scene contains a floor, a red left wall, and a green sphere in the middle with a hard shadow. Provide two buttons: "Local Illumination" and "Global Illumination". When "Local" is active, the scene is as described. When the "Global Illumination" button is clicked, animate two changes: 1. The hard shadow under the sphere smoothly transitions to a softer, more diffuse shadow. 2. A faint red glow (color bleeding) appears on the floor near the red wall. This demonstrates the key visual differences interactively.
                -->
                <p class="interactive-title">点击按钮，观察光照效果的变化</p>
                <div class="interactive-scene-container">
                    <div class="scene" id="comparison-scene">
                        <div class="floor"></div>
                        <div class="wall-left"></div>
                        <div class="sphere"></div>
                    </div>
                    <div class="controls">
                        <button id="btn-local">局部光照 (Local)</button>
                        <button id="btn-global">全局光照 (Global)</button>
                    </div>
                </div>
                <p class="fragment">请注意全局光照下的<span style="color:red;">颜色溢出</span>和<span style="color:blue;">柔和阴影</span>。</p>
            </section>
            
            <section>
                <h3>全局光照的渲染方法</h3>
                <p>主要有两种经典技术来实现全局光照：</p>
                <div class="container-flex">
                    <div class="col-2 fragment">
                        <h5>光线追踪 (Ray Tracing)</h5>
                        <!-- Image URL: a diagram illustrating ray tracing from https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Ray_trace_diagram.svg/1200px-Ray_trace_diagram.svg.png -->
                        <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Ray_trace_diagram.svg/1200px-Ray_trace_diagram.svg.png" height="250">
                        <p>从相机反向追踪光线路径。<br>擅长处理<span style="color:blue;">镜面反射、折射、精确阴影</span>。</p>
                    </div>
                    <div class="col-2 fragment">
                        <h5>辐射度 (Radiosity)</h5>
                        <!-- Image URL: a diagram illustrating radiosity from https://accad.osu.edu/research/gose/radiosity/rad_files/image002.gif -->
                        <img src="https://accad.osu.edu/research/gose/radiosity/rad_files/image002.gif" height="250">
                        <p>计算表面之间的光能传递。<br>擅长处理<span style="color:red;">漫反射间的颜色溢出、柔和光照</span>。</p>
                    </div>
                </div>
            </section>
            
            <section>
                <h3>深入探索：光线追踪</h3>
                <p>光线追踪通过模拟每一条光线的旅程来确定像素的颜色。</p>
                <ul>
                    <li class="fragment"><strong>主光线 (Primary Ray):</strong> 从相机发出，穿过像素，射入场景。</li>
                    <li class="fragment"><strong>阴影光线 (Shadow Ray):</strong> 从交点射向光源，检测是否被遮挡。</li>
                    <li class="fragment"><strong>反射/折射光线 (Secondary Rays):</strong> 如果表面是反射/折射材质，光线会继续弹跳。</li>
                </ul>
                <p class="fragment">让我们通过一个交互式示例来亲手“追踪”光线！</p>
            </section>
            
            <section>
                 <h3>交互式示例：2D光线追踪模拟器</h3>
                <!-- Interactive App Prompt:
                Title: Interactive 2D Ray Tracer
                Description: Create a 2D visualization on an HTML canvas. The scene includes a camera icon on the left, a light source icon on the top, a blue diffuse sphere, a silver reflective sphere, and a floor. A 'screen' line is shown in front of the camera. The user can click anywhere on the canvas. When clicked, a primary ray is animated from the camera towards the click point.
                - If it hits the blue sphere, it stops. A dashed shadow ray is then cast towards the light. If it hits another object, a "SHADOW" text appears; otherwise, a "LIT" text appears.
                - If it hits the silver sphere, it reflects. A secondary reflection ray is cast.
                - If it hits the floor, it stops and casts a shadow ray.
                - A "Reset" button clears all drawn rays.
                This visually demonstrates the fundamental algorithm of ray tracing.
                -->
                <p class="interactive-title">在画布上点击，从相机发射光线来探索场景</p>
                <div class="interactive-scene-container" style="height: auto; text-align: center;">
                    <canvas id="ray-tracing-canvas" width="580" height="350"></canvas>
                    <div class="controls">
                        <button id="btn-reset-rays">重置 (Reset)</button>
                    </div>
                </div>
            </section>

            <section>
                <h3>总结</h3>
                <ul>
                    <li class="fragment"><strong>局部光照</strong> 快速但简单，只考虑直接光。</li>
                    <li class="fragment"><strong>全局光照</strong> 逼真但消耗资源，模拟光的反弹。</li>
                    <li class="fragment"><strong>光线追踪</strong> 和 <strong>辐射度</strong> 是实现全局光照的强大技术。</li>
                    <li class="fragment">现代图形学正在努力将全局光照技术（如实时光线追踪）带入更多实时应用中。</li>
                </ul>
            </section>

        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/notes/notes.js"></script>
    <script>
        Reveal.initialize({
            hash: true,
            plugins: [ RevealNotes ],
            slideNumber: true,
        });

        // Interactive Scene Logic
        const scene = document.getElementById('comparison-scene');
        const btnLocal = document.getElementById('btn-local');
        const btnGlobal = document.getElementById('btn-global');

        if (scene) {
            btnLocal.onclick = () => scene.classList.remove('global');
            btnGlobal.onclick = () => scene.classList.add('global');
        }

        // Interactive Ray Tracing Logic
        const canvas = document.getElementById('ray-tracing-canvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            const btnReset = document.getElementById('btn-reset-rays');
            
            const camera = { x: 50, y: canvas.height / 2 };
            const light = { x: canvas.width / 2, y: 30, size: 15 };
            const sceneObjects = [
                { type: 'sphere', x: 250, y: 200, radius: 50, color: '#42a5f5', material: 'diffuse' }, // Blue diffuse
                { type: 'sphere', x: 450, y: 150, radius: 40, color: '#bdbdbd', material: 'reflective' }, // Silver reflective
                { type: 'plane', y: canvas.height - 30, color: '#78909c' }
            ];

            function drawScene() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw Camera (Eye icon)
                ctx.fillStyle = '#424242';
                ctx.font = '30px sans-serif';
                ctx.fillText('👁️', camera.x - 20, camera.y + 10);

                // Draw Light (Sun icon)
                ctx.fillStyle = '#FFEB3B';
                ctx.font = '30px sans-serif';
                ctx.fillText('☀️', light.x - light.size, light.y + light.size);

                // Draw Objects
                sceneObjects.forEach(obj => {
                    if (obj.type === 'sphere') {
                        ctx.beginPath();
                        ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
                        ctx.fillStyle = obj.color;
                        ctx.fill();
                        // fake highlight
                        ctx.beginPath();
                        ctx.arc(obj.x-10, obj.y-10, obj.radius/4, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255,255,255,0.7)';
                        ctx.fill();
                    } else if (obj.type === 'plane') {
                        ctx.fillStyle = obj.color;
                        ctx.fillRect(0, obj.y, canvas.width, canvas.height - obj.y);
                    }
                });
            }

            function intersect(ray, objects) {
                let closestHit = null;
                let minDistance = Infinity;

                objects.forEach(obj => {
                    if (obj.type === 'sphere') {
                        const oc = { x: ray.origin.x - obj.x, y: ray.origin.y - obj.y };
                        const a = ray.dir.x * ray.dir.x + ray.dir.y * ray.dir.y;
                        const b = 2.0 * (oc.x * ray.dir.x + oc.y * ray.dir.y);
                        const c = (oc.x * oc.x + oc.y * oc.y) - obj.radius * obj.radius;
                        const discriminant = b * b - 4 * a * c;
                        if (discriminant >= 0) {
                            const t = (-b - Math.sqrt(discriminant)) / (2.0 * a);
                            if (t > 0.001 && t < minDistance) {
                                minDistance = t;
                                closestHit = {
                                    t: t,
                                    point: { x: ray.origin.x + t * ray.dir.x, y: ray.origin.y + t * ray.dir.y },
                                    object: obj,
                                    normal: { x: (ray.origin.x + t * ray.dir.x - obj.x) / obj.radius, y: (ray.origin.y + t * ray.dir.y - obj.y) / obj.radius }
                                };
                            }
                        }
                    } else if (obj.type === 'plane') {
                        if(ray.dir.y > 0) { // moving downwards
                           const t = (obj.y - ray.origin.y) / ray.dir.y;
                           if(t > 0.001 && t < minDistance) {
                                minDistance = t;
                                closestHit = {
                                    t: t,
                                    point: { x: ray.origin.x + t * ray.dir.x, y: ray.origin.y + t * ray.dir.y },
                                    object: obj,
                                    normal: { x: 0, y: -1 }
                                };
                           }
                        }
                    }
                });
                return closestHit;
            }

            function trace(ray) {
                // Draw primary ray
                ctx.beginPath();
                ctx.moveTo(ray.origin.x, ray.origin.y);
                const hit = intersect(ray, sceneObjects);
                
                if (hit) {
                    ctx.lineTo(hit.point.x, hit.point.y);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Shadow ray
                    const shadowRayDir = { x: light.x - hit.point.x, y: light.y - hit.point.y };
                    const shadowRayDist = Math.sqrt(shadowRayDir.x * shadowRayDir.x + shadowRayDir.y * shadowRayDir.y);
                    shadowRayDir.x /= shadowRayDist;
                    shadowRayDir.y /= shadowRayDist;
                    const shadowRay = { origin: hit.point, dir: shadowRayDir };
                    
                    const shadowHit = intersect(shadowRay, sceneObjects);
                    
                    ctx.beginPath();
                    ctx.moveTo(hit.point.x, hit.point.y);
                    ctx.lineTo(light.x, light.y);
                    ctx.setLineDash([5, 5]);
                    ctx.lineWidth = 1;
                    
                    if (shadowHit && shadowHit.t < shadowRayDist) {
                        ctx.strokeStyle = 'red';
                        ctx.stroke();
                        ctx.fillStyle = 'red';
                        ctx.fillText('阴影 (SHADOW)', hit.point.x + 10, hit.point.y - 10);
                    } else {
                         ctx.strokeStyle = 'orange';
                         ctx.stroke();
                         ctx.fillStyle = 'green';
                         ctx.fillText('照亮 (LIT)', hit.point.x + 10, hit.point.y - 10);
                    }
                    ctx.setLineDash([]);
                    
                    // Reflection ray
                    if (hit.object.material === 'reflective') {
                        const d = ray.dir;
                        const n = hit.normal;
                        const dot = 2 * (d.x * n.x + d.y * n.y);
                        const reflectDir = { x: d.x - dot * n.x, y: d.y - dot * n.y };
                        const reflectRay = { origin: hit.point, dir: reflectDir };
                        
                        ctx.beginPath();
                        ctx.moveTo(reflectRay.origin.x, reflectRay.origin.y);
                        ctx.lineTo(reflectRay.origin.x + reflectRay.dir.x * 300, reflectRay.origin.y + reflectRay.dir.y * 300);
                        ctx.strokeStyle = 'purple';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                } else {
                    ctx.lineTo(ray.origin.x + ray.dir.x * canvas.width, ray.origin.y + ray.dir.y * canvas.width);
                    ctx.strokeStyle = '#aaaaaa';
                    ctx.stroke();
                }
            }

            canvas.addEventListener('click', (e) => {
                drawScene(); // Redraw scene to clear previous rays
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const dir = { x: mouseX - camera.x, y: mouseY - camera.y };
                const mag = Math.sqrt(dir.x * dir.x + dir.y * dir.y);
                dir.x /= mag;
                dir.y /= mag;

                trace({ origin: camera, dir: dir });
            });

            btnReset.onclick = drawScene;

            drawScene();
        }

    </script>
</body>
</html>
