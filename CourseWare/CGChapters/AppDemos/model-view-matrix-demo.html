<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>模型视图矩阵交互式教学演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }
        .matrix {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            font-family: monospace;
            text-align: center;
            font-size: 0.875rem;
        }
        .matrix span {
            padding: 6px 4px;
            background-color: #1f2937;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        .matrix span:hover {
            background-color: #374151;
        }
        .slider::-webkit-slider-thumb {
            background-color: #3b82f6;
            transition: background-color 0.2s ease;
        }
        .slider::-webkit-slider-thumb:hover {
            background-color: #2563eb;
        }
        .canvas-container {
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }
        .info-card {
            background-color: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 20px rgba(0, 0, 0, 0.4);
        }
        .btn {
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }
        .btn:hover::after {
            width: 300px;
            height: 300px;
        }
        .tab-active {
            border-bottom: 2px solid #3b82f6;
            color: #3b82f6;
        }
        @media (max-width: 768px) {
            .matrix {
                font-size: 0.75rem;
            }
            .matrix span {
                padding: 4px 2px;
            }
        }
    </style>
</head>
<body class="p-4 md:p-6">
    <div class="max-w-7xl mx-auto">
        <!-- 标题和介绍 -->
        <div class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-400 mb-4">模型视图矩阵交互式教学演示</h1>
            <p class="text-gray-400 max-w-3xl mx-auto">
                此演示展示了计算机图形学中模型视图矩阵的作用。您可以选择变换物体坐标系或相机坐标系，观察它们对最终成像的影响。
            </p>
        </div>

        <!-- 主内容区域 -->
        <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            <!-- 左侧控制面板 -->
            <div class="lg:col-span-1 space-y-6">
                <!-- 变换模式选择 -->
                <div class="info-card rounded-xl p-5">
                    <h3 class="text-xl font-semibold mb-4 text-white">变换模式选择</h3>
                    <div class="space-y-4">
                        <div class="flex space-x-2">
                            <button id="object-mode-btn" class="btn flex-1 py-3 px-4 bg-blue-600 text-white rounded-lg tab-active">
                                变换物体
                            </button>
                            <button id="camera-mode-btn" class="btn flex-1 py-3 px-4 bg-gray-700 text-gray-300 rounded-lg">
                                变换相机
                            </button>
                        </div>
                        <p class="text-sm text-gray-400 mt-2">
                            选择"变换物体"将改变物体在世界坐标系中的位置和方向；
                            选择"变换相机"将改变相机的观察位置和方向。
                        </p>
                    </div>
                </div>

                <!-- 模型选择 -->
                <div class="info-card rounded-xl p-5">
                    <h3 class="text-xl font-semibold mb-4 text-white">模型选择</h3>
                    <select id="model-selector" class="w-full bg-gray-700 text-white border border-gray-600 rounded-lg p-3">
                        <option value="cube">立方体</option>
                        <option value="sphere">球体</option>
                        <option value="teapot">茶壶</option>
                    </select>
                </div>

                <!-- 物体变换控制 -->
                <div id="object-controls" class="info-card rounded-xl p-5">
                    <h3 class="text-xl font-semibold mb-4 text-white">物体变换参数</h3>
                    
                    <div class="space-y-5">
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 X</label>
                                <span id="object-pos-x" class="text-blue-400">0.0</span>
                            </div>
                            <input type="range" id="object-tx" min="-10" max="10" step="0.1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 Y</label>
                                <span id="object-pos-y" class="text-blue-400">0.0</span>
                            </div>
                            <input type="range" id="object-ty" min="-10" max="10" step="0.1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 Z</label>
                                <span id="object-pos-z" class="text-blue-400">-5.0</span>
                            </div>
                            <input type="range" id="object-tz" min="-20" max="5" step="0.1" value="-5" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 X</label>
                                <span id="object-rot-x" class="text-blue-400">0°</span>
                            </div>
                            <input type="range" id="object-rx" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 Y</label>
                                <span id="object-rot-y" class="text-blue-400">0°</span>
                            </div>
                            <input type="range" id="object-ry" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 Z</label>
                                <span id="object-rot-z" class="text-blue-400">0°</span>
                            </div>
                            <input type="range" id="object-rz" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>

                <!-- 相机变换控制 -->
                <div id="camera-controls" class="info-card rounded-xl p-5 hidden">
                    <h3 class="text-xl font-semibold mb-4 text-white">相机变换参数</h3>
                    
                    <div class="space-y-5">
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 X</label>
                                <span id="camera-pos-x" class="text-green-400">0.0</span>
                            </div>
                            <input type="range" id="camera-tx" min="-10" max="10" step="0.1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 Y</label>
                                <span id="camera-pos-y" class="text-green-400">0.0</span>
                            </div>
                            <input type="range" id="camera-ty" min="-10" max="10" step="0.1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">位置 Z</label>
                                <span id="camera-pos-z" class="text-green-400">0.0</span>
                            </div>
                            <input type="range" id="camera-tz" min="-10" max="20" step="0.1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 X</label>
                                <span id="camera-rot-x" class="text-green-400">0°</span>
                            </div>
                            <input type="range" id="camera-rx" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 Y</label>
                                <span id="camera-rot-y" class="text-green-400">0°</span>
                            </div>
                            <input type="range" id="camera-ry" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        
                        <div>
                            <div class="flex justify-between mb-1">
                                <label class="text-gray-300">旋转 Z</label>
                                <span id="camera-rot-z" class="text-green-400">0°</span>
                            </div>
                            <input type="range" id="camera-rz" min="-180" max="180" step="1" value="0" class="slider w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                </div>

                <!-- 重置按钮 -->
                <button id="reset-btn" class="btn w-full py-4 bg-red-600 hover:bg-red-700 text-white rounded-xl font-medium">
                    重置所有变换
                </button>
            </div>

            <!-- 中间渲染区域 -->
            <div class="lg:col-span-2 space-y-6">
                <!-- 渲染画布 -->
                <div class="info-card rounded-xl p-5">
                    <h3 class="text-xl font-semibold mb-4 text-white">相机视图 (正交投影)</h3>
                    <div class="canvas-container rounded-lg bg-black p-4">
                        <canvas id="mainCanvas" width="600" height="400" class="w-full"></canvas>
                    </div>
                    
                    <!-- 图例 -->
                    <div class="mt-4 text-sm text-gray-400 grid grid-cols-1 md:grid-cols-2 gap-2">
                        <p><span class="inline-block w-3 h-3 bg-red-500 mr-2"></span>X轴 | <span class="inline-block w-3 h-3 bg-green-500 mr-2"></span>Y轴 | <span class="inline-block w-3 h-3 bg-blue-500 mr-2"></span>Z轴</p>
                        <p><span class="inline-block w-3 h-3 bg-yellow-500 rounded-full mr-2"></span>物体顶点 | <span class="inline-block w-3 h-3 bg-white mr-2"></span>物体边缘</p>
                    </div>
                </div>

                <!-- 变换信息 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- 物体变换信息 -->
                    <div class="info-card rounded-xl p-5">
                        <h3 class="text-xl font-semibold mb-4 text-blue-400">物体变换信息</h3>
                        <div class="space-y-3">
                            <p><strong>位置:</strong> <span id="obj-position-display">0.0, 0.0, -5.0</span></p>
                            <p><strong>旋转:</strong> <span id="obj-rotation-display">0°, 0°, 0°</span></p>
                            
                            <h4 class="font-semibold mt-4 mb-2 text-gray-300">模型矩阵</h4>
                            <div id="model-matrix" class="matrix bracketed"></div>
                        </div>
                    </div>

                    <!-- 相机变换信息 -->
                    <div class="info-card rounded-xl p-5">
                        <h3 class="text-xl font-semibold mb-4 text-green-400">相机变换信息</h3>
                        <div class="space-y-3">
                            <p><strong>位置:</strong> <span id="cam-position-display">0.0, 0.0, 0.0</span></p>
                            <p><strong>旋转:</strong> <span id="cam-rotation-display">0°, 0°, 0°</span></p>
                            
                            <h4 class="font-semibold mt-4 mb-2 text-gray-300">视图矩阵</h4>
                            <div id="view-matrix" class="matrix bracketed"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 右侧模型视图矩阵区域 -->
            <div class="lg:col-span-1 space-y-6">
                <!-- 模型视图矩阵 -->
                <div class="info-card rounded-xl p-5 h-full">
                    <h3 class="text-xl font-semibold mb-4 text-purple-400">模型视图矩阵 (View × Model)</h3>
                    <div id="mv-matrix" class="matrix bracketed"></div>
                    <p class="text-sm text-gray-400 mt-4">
                        模型视图矩阵将物体从局部坐标系变换到相机坐标系。在计算机图形学管线中，这是渲染过程的关键步骤。
                        矩阵的每一行代表相机坐标系中的一个基向量和原点位置。
                    </p>
                </div>
            </div>
            </div>
        </div>

        <!-- 教学说明 -->
        <div class="mt-10 info-card rounded-xl p-6">
            <h3 class="text-2xl font-semibold mb-4 text-white">模型视图矩阵教学说明</h3>
            <div class="space-y-4 text-gray-300">
                <p>
                    <strong class="text-blue-400">模型矩阵(Model Matrix):</strong> 描述物体在世界坐标系中的位置、方向和缩放。
                    当您移动或旋转物体时，就是在修改这个矩阵。
                </p>
                <p>
                    <strong class="text-green-400">视图矩阵(View Matrix):</strong> 描述相机在世界坐标系中的位置和观察方向。
                    它实际上是相机变换的逆变换，将世界坐标系中的点转换到相机坐标系。
                </p>
                <p>
                    <strong class="text-purple-400">模型视图矩阵(Model-View Matrix):</strong> 是视图矩阵和模型矩阵的乘积，
                    它将物体从局部坐标系直接变换到相机坐标系。在图形管线中，这是顶点着色器的主要任务之一。
                </p>
                <p>
                    <strong>关键概念:</strong> 移动物体一个单位和向相反方向移动相机一个单位，在视觉上会产生相同的效果。
                    这展示了模型变换和视图变换在某种程度上的对偶性。
                </p>
            </div>
        </div>

        <!-- 页脚 -->
        <footer class="mt-12 text-center text-gray-500 text-sm pb-6">
            <p>计算机图形学教学演示 © 2025</p>
        </footer>
    </div>

    <script>
        // 全局状态
        const state = {
            objectPosition: { x: 0, y: 0, z: -5 },
            objectRotation: { x: 0, y: 0, z: 0 },
            cameraPosition: { x: 0, y: 0, z: 0 },
            cameraRotation: { x: 0, y: 0, z: 0 },
            transformMode: 'object', // 'object' or 'camera'
            selectedModel: 'cube',
            canvas: null,
            ctx: null
        };

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            // 获取DOM元素
            state.canvas = document.getElementById('mainCanvas');
            state.ctx = state.canvas.getContext('2d');
            
            // 设置Canvas尺寸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // 初始化矩阵显示
            updateMatrixDisplays();
            
            // 绑定事件监听
            bindEventListeners();
            
            // 初始渲染
            render();
        });

        // 调整Canvas尺寸以适应容器
        function resizeCanvas() {
            const container = state.canvas.parentElement;
            const width = container.clientWidth;
            const height = width * 2 / 3; // 保持3:2的宽高比
            
            state.canvas.width = width;
            state.canvas.height = height;
            
            // 重新渲染
            render();
        }

        // 绑定事件监听器
        function bindEventListeners() {
            // 模式切换按钮
            document.getElementById('object-mode-btn').addEventListener('click', () => {
                setState({ transformMode: 'object' });
                document.getElementById('object-mode-btn').classList.add('tab-active', 'bg-blue-600', 'text-white');
                document.getElementById('object-mode-btn').classList.remove('bg-gray-700', 'text-gray-300');
                document.getElementById('camera-mode-btn').classList.remove('tab-active', 'bg-blue-600', 'text-white');
                document.getElementById('camera-mode-btn').classList.add('bg-gray-700', 'text-gray-300');
                document.getElementById('object-controls').classList.remove('hidden');
                document.getElementById('camera-controls').classList.add('hidden');
            });
            
            document.getElementById('camera-mode-btn').addEventListener('click', () => {
                setState({ transformMode: 'camera' });
                document.getElementById('camera-mode-btn').classList.add('tab-active', 'bg-blue-600', 'text-white');
                document.getElementById('camera-mode-btn').classList.remove('bg-gray-700', 'text-gray-300');
                document.getElementById('object-mode-btn').classList.remove('tab-active', 'bg-blue-600', 'text-white');
                document.getElementById('object-mode-btn').classList.add('bg-gray-700', 'text-gray-300');
                document.getElementById('camera-controls').classList.remove('hidden');
                document.getElementById('object-controls').classList.add('hidden');
            });
            
            // 模型选择
            document.getElementById('model-selector').addEventListener('change', (e) => {
                setState({ selectedModel: e.target.value });
            });
            
            // 物体变换控件
            document.getElementById('object-tx').addEventListener('input', (e) => {
                setState({ objectPosition: { ...state.objectPosition, x: parseFloat(e.target.value) } });
            });
            
            document.getElementById('object-ty').addEventListener('input', (e) => {
                setState({ objectPosition: { ...state.objectPosition, y: parseFloat(e.target.value) } });
            });
            
            document.getElementById('object-tz').addEventListener('input', (e) => {
                setState({ objectPosition: { ...state.objectPosition, z: parseFloat(e.target.value) } });
            });
            
            document.getElementById('object-rx').addEventListener('input', (e) => {
                setState({ objectRotation: { ...state.objectRotation, x: parseFloat(e.target.value) } });
            });
            
            document.getElementById('object-ry').addEventListener('input', (e) => {
                setState({ objectRotation: { ...state.objectRotation, y: parseFloat(e.target.value) } });
            });
            
            document.getElementById('object-rz').addEventListener('input', (e) => {
                setState({ objectRotation: { ...state.objectRotation, z: parseFloat(e.target.value) } });
            });
            
            // 相机变换控件
            document.getElementById('camera-tx').addEventListener('input', (e) => {
                setState({ cameraPosition: { ...state.cameraPosition, x: parseFloat(e.target.value) } });
            });
            
            document.getElementById('camera-ty').addEventListener('input', (e) => {
                setState({ cameraPosition: { ...state.cameraPosition, y: parseFloat(e.target.value) } });
            });
            
            document.getElementById('camera-tz').addEventListener('input', (e) => {
                setState({ cameraPosition: { ...state.cameraPosition, z: parseFloat(e.target.value) } });
            });
            
            document.getElementById('camera-rx').addEventListener('input', (e) => {
                setState({ cameraRotation: { ...state.cameraRotation, x: parseFloat(e.target.value) } });
            });
            
            document.getElementById('camera-ry').addEventListener('input', (e) => {
                setState({ cameraRotation: { ...state.cameraRotation, y: parseFloat(e.target.value) } });
            });
            
            document.getElementById('camera-rz').addEventListener('input', (e) => {
                setState({ cameraRotation: { ...state.cameraRotation, z: parseFloat(e.target.value) } });
            });
            
            // 重置按钮
            document.getElementById('reset-btn').addEventListener('click', () => {
                setState({
                    objectPosition: { x: 0, y: 0, z: -5 },
                    objectRotation: { x: 0, y: 0, z: 0 },
                    cameraPosition: { x: 0, y: 0, z: 0 },
                    cameraRotation: { x: 0, y: 0, z: 0 }
                });
                
                // 重置滑块值
                document.getElementById('object-tx').value = 0;
                document.getElementById('object-ty').value = 0;
                document.getElementById('object-tz').value = -5;
                document.getElementById('object-rx').value = 0;
                document.getElementById('object-ry').value = 0;
                document.getElementById('object-rz').value = 0;
                
                document.getElementById('camera-tx').value = 0;
                document.getElementById('camera-ty').value = 0;
                document.getElementById('camera-tz').value = 0;
                document.getElementById('camera-rx').value = 0;
                document.getElementById('camera-ry').value = 0;
                document.getElementById('camera-rz').value = 0;
            });
        }

        // 更新状态并触发重新渲染
        function setState(newState) {
            Object.assign(state, newState);
            updateUI();
            updateMatrixDisplays();
            render();
        }

        // 更新UI显示
        function updateUI() {
            // 更新物体变换显示
            document.getElementById('object-pos-x').textContent = state.objectPosition.x.toFixed(1);
            document.getElementById('object-pos-y').textContent = state.objectPosition.y.toFixed(1);
            document.getElementById('object-pos-z').textContent = state.objectPosition.z.toFixed(1);
            document.getElementById('object-rot-x').textContent = state.objectRotation.x.toFixed(0) + '°';
            document.getElementById('object-rot-y').textContent = state.objectRotation.y.toFixed(0) + '°';
            document.getElementById('object-rot-z').textContent = state.objectRotation.z.toFixed(0) + '°';
            
            // 更新相机变换显示
            document.getElementById('camera-pos-x').textContent = state.cameraPosition.x.toFixed(1);
            document.getElementById('camera-pos-y').textContent = state.cameraPosition.y.toFixed(1);
            document.getElementById('camera-pos-z').textContent = state.cameraPosition.z.toFixed(1);
            document.getElementById('camera-rot-x').textContent = state.cameraRotation.x.toFixed(0) + '°';
            document.getElementById('camera-rot-y').textContent = state.cameraRotation.y.toFixed(0) + '°';
            document.getElementById('camera-rot-z').textContent = state.cameraRotation.z.toFixed(0) + '°';
            
            // 更新变换信息面板
            document.getElementById('obj-position-display').textContent = 
                `${state.objectPosition.x.toFixed(1)}, ${state.objectPosition.y.toFixed(1)}, ${state.objectPosition.z.toFixed(1)}`;
            document.getElementById('obj-rotation-display').textContent = 
                `${state.objectRotation.x.toFixed(0)}°, ${state.objectRotation.y.toFixed(0)}°, ${state.objectRotation.z.toFixed(0)}°`;
            
            document.getElementById('cam-position-display').textContent = 
                `${state.cameraPosition.x.toFixed(1)}, ${state.cameraPosition.y.toFixed(1)}, ${state.cameraPosition.z.toFixed(1)}`;
            document.getElementById('cam-rotation-display').textContent = 
                `${state.cameraRotation.x.toFixed(0)}°, ${state.cameraRotation.y.toFixed(0)}°, ${state.cameraRotation.z.toFixed(0)}°`;
        }

        // 矩阵运算函数
        function createTranslationMatrix(x, y, z) {
            return [
                [1, 0, 0, x],
                [0, 1, 0, y],
                [0, 0, 1, z],
                [0, 0, 0, 1]
            ];
        }

        function createRotationMatrixX(angle) {
            const rad = angle * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            return [
                [1, 0, 0, 0],
                [0, cos, -sin, 0],
                [0, sin, cos, 0],
                [0, 0, 0, 1]
            ];
        }

        function createRotationMatrixY(angle) {
            const rad = angle * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            return [
                [cos, 0, sin, 0],
                [0, 1, 0, 0],
                [-sin, 0, cos, 0],
                [0, 0, 0, 1]
            ];
        }

        function createRotationMatrixZ(angle) {
            const rad = angle * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            return [
                [cos, -sin, 0, 0],
                [sin, cos, 0, 0],
                [0, 0, 1, 0],
                [0, 0, 0, 1]
            ];
        }

        function multiplyMatrices(a, b) {
            const result = Array(4).fill().map(() => Array(4).fill(0));
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    for (let k = 0; k < 4; k++) {
                        result[i][j] += a[i][k] * b[k][j];
                    }
                }
            }
            return result;
        }

        function transformPoint(matrix, point) {
            const [x, y, z] = point;
            const result = [
                matrix[0][0] * x + matrix[0][1] * y + matrix[0][2] * z + matrix[0][3],
                matrix[1][0] * x + matrix[1][1] * y + matrix[1][2] * z + matrix[1][3],
                matrix[2][0] * x + matrix[2][1] * y + matrix[2][2] * z + matrix[2][3],
                matrix[3][0] * x + matrix[3][1] * y + matrix[3][2] * z + matrix[3][3]
            ];
            return [result[0]/result[3], result[1]/result[3], result[2]/result[3]];
        }

        // 获取模型顶点
        function getModelVertices(model) {
            switch (model) {
                case 'cube':
                    return [
                        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
                    ];
                case 'teapot':
                    // 简化的茶壶轮廓点
                    const teapotPoints = [];
                    for (let i = 0; i < 16; i++) {
                        const angle = (i / 16) * 2 * Math.PI;
                        teapotPoints.push([Math.cos(angle) * 1.5, -1, Math.sin(angle) * 1.5]);
                        teapotPoints.push([Math.cos(angle) * 1.2, 0, Math.sin(angle) * 1.2]);
                        teapotPoints.push([Math.cos(angle) * 0.8, 1, Math.sin(angle) * 0.8]);
                    }
                    return teapotPoints;
                case 'sphere':
                    // 简化的球体点
                    const spherePoints = [];
                    for (let i = 0; i < 12; i++) {
                        for (let j = 0; j < 8; j++) {
                            const phi = (i / 12) * Math.PI;
                            const theta = (j / 8) * 2 * Math.PI;
                            spherePoints.push([
                                Math.sin(phi) * Math.cos(theta),
                                Math.cos(phi),
                                Math.sin(phi) * Math.sin(theta)
                            ]);
                        }
                    }
                    return spherePoints;
                default:
                    return [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1]];
            }
        }

        // 渲染函数
        function render() {
            const canvas = state.canvas;
            const ctx = state.ctx;
            const width = canvas.width;
            const height = canvas.height;
            
            // 清空画布
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            // X轴 (红色)
            ctx.strokeStyle = '#ff4444';
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(width/2, height/2);
            ctx.lineTo(width/2 + 50, height/2);
            ctx.stroke();
            
            // Y轴 (绿色)
            ctx.strokeStyle = '#44ff44';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2);
            ctx.lineTo(width/2, height/2 - 50);
            ctx.stroke();
            
            // Z轴 (蓝色) - 用斜线表示
            ctx.strokeStyle = '#4444ff';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2);
            ctx.lineTo(width/2 + 35, height/2 + 35);
            ctx.stroke();
            
            // 计算变换矩阵
            let modelMatrix = createTranslationMatrix(state.objectPosition.x, state.objectPosition.y, state.objectPosition.z);
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixY(state.objectRotation.y));
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixX(state.objectRotation.x));
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixZ(state.objectRotation.z));
            
            let viewMatrix = createTranslationMatrix(-state.cameraPosition.x, -state.cameraPosition.y, -state.cameraPosition.z);
            viewMatrix = multiplyMatrices(createRotationMatrixZ(-state.cameraRotation.z), viewMatrix);
            viewMatrix = multiplyMatrices(createRotationMatrixX(-state.cameraRotation.x), viewMatrix);
            viewMatrix = multiplyMatrices(createRotationMatrixY(-state.cameraRotation.y), viewMatrix);
            
            const mvMatrix = multiplyMatrices(viewMatrix, modelMatrix);
            
            // 获取并变换模型顶点
            const vertices = getModelVertices(state.selectedModel);
            const transformedVertices = vertices.map(vertex => transformPoint(mvMatrix, vertex));
            
            // 正交投影并绘制
            ctx.fillStyle = '#ffaa00';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            
            transformedVertices.forEach(vertex => {
                const [x, y, z] = vertex;
                const screenX = width/2 + x * 50;
                const screenY = height/2 - y * 50;
                
                // 绘制点
                ctx.beginPath();
                ctx.arc(screenX, screenY, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // 如果是立方体，绘制边
            if (state.selectedModel === 'cube' && transformedVertices.length === 8) {
                const edges = [
                    [0,1], [1,2], [2,3], [3,0], // 后面
                    [4,5], [5,6], [6,7], [7,4], // 前面
                    [0,4], [1,5], [2,6], [3,7]  // 连接线
                ];
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                
                edges.forEach(([i, j]) => {
                    const [x1, y1] = transformedVertices[i];
                    const [x2, y2] = transformedVertices[j];
                    
                    ctx.beginPath();
                    ctx.moveTo(width/2 + x1 * 50, height/2 - y1 * 50);
                    ctx.lineTo(width/2 + x2 * 50, height/2 - y2 * 50);
                    ctx.stroke();
                });
            }
        }

        // 更新矩阵显示
        function updateMatrixDisplays() {
            // 计算变换矩阵
            let modelMatrix = createTranslationMatrix(state.objectPosition.x, state.objectPosition.y, state.objectPosition.z);
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixY(state.objectRotation.y));
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixX(state.objectRotation.x));
            modelMatrix = multiplyMatrices(modelMatrix, createRotationMatrixZ(state.objectRotation.z));
            
            let viewMatrix = createTranslationMatrix(-state.cameraPosition.x, -state.cameraPosition.y, -state.cameraPosition.z);
            viewMatrix = multiplyMatrices(createRotationMatrixZ(-state.cameraRotation.z), viewMatrix);
            viewMatrix = multiplyMatrices(createRotationMatrixX(-state.cameraRotation.x), viewMatrix);
            viewMatrix = multiplyMatrices(createRotationMatrixY(-state.cameraRotation.y), viewMatrix);
            
            const mvMatrix = multiplyMatrices(viewMatrix, modelMatrix);
            
            // 更新模型矩阵显示
            displayMatrix('model-matrix', modelMatrix);
            
            // 更新视图矩阵显示
            displayMatrix('view-matrix', viewMatrix);
            
            // 更新模型视图矩阵显示
            displayMatrix('mv-matrix', mvMatrix);
        }

        // 在HTML中显示矩阵
        function displayMatrix(elementId, matrix) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            
            // 遍历矩阵的每一行和每一列
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('span');
                    // 格式化数字，保留2位小数
                    cell.textContent = matrix[i][j].toFixed(2);
                    container.appendChild(cell);
                }
            }
        }
    </script>
</body>
</html>