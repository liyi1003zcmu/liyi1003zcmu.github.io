<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>交互式变换课堂</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Noto Sans SC', sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>

    <script>
        // --- 核心应用逻辑 ---
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        // --- 状态管理 ---
        const state = {
            currentScene: 'intro',
            scenes: ['intro', 'basic', 'homogeneous', 'composite', 'mvp', 'sandbox'],
            sidebar: {
                width: 200,
                buttons: [
                    { id: 'intro', text: '课程简介' },
                    { id: 'basic', text: '二维基本变换' },
                    { id: 'homogeneous', text: '齐次坐标' },
                    { id: 'composite', text: '复合变换' },
                    { id: 'mvp', text: 'MVP流水线' },
                    { id: 'sandbox', text: '交互式沙盒' },
                ],
                hoveredButton: null,
            },
            // 各个场景的独立状态
            basic: {
                tx: 0, ty: 0,
                angle: 0,
                sx: 1, sy: 1,
            },
            composite: {
                order: 'TR', // 'TR' or 'RT'
            },
            sandbox: {
                objects: [],
                selectedIndex: -1,
                keys: {},
            }
        };

        // --- 最小化矩阵库 (3x3 for 2D Homogeneous) ---
        const mat3 = {
            create: () => [1, 0, 0, 0, 1, 0, 0, 0, 1],
            identity: (out) => {
                out[0] = 1; out[1] = 0; out[2] = 0;
                out[3] = 0; out[4] = 1; out[5] = 0;
                out[6] = 0; out[7] = 0; out[8] = 1;
                return out;
            },
            translate: (out, a, v) => {
                let a00 = a[0], a01 = a[1], a02 = a[2];
                let a10 = a[3], a11 = a[4], a12 = a[5];
                let a20 = a[6], a21 = a[7], a22 = a[8];
                let x = v[0], y = v[1];
                out[0] = a00; out[1] = a01; out[2] = a02;
                out[3] = a10; out[4] = a11; out[5] = a12;
                out[6] = a00 * x + a10 * y + a20;
                out[7] = a01 * x + a11 * y + a21;
                out[8] = a02 * x + a12 * y + a22;
                return out;
            },
            rotate: (out, a, rad) => {
                let a00 = a[0], a01 = a[1], a02 = a[2];
                let a10 = a[3], a11 = a[4], a12 = a[5];
                let s = Math.sin(rad);
                let c = Math.cos(rad);
                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a00 * -s + a10 * c;
                out[4] = a01 * -s + a11 * c;
                out[5] = a02 * -s + a12 * c;
                out[6] = a[6]; out[7] = a[7]; out[8] = a[8];
                return out;
            },
            scale: (out, a, v) => {
                let x = v[0], y = v[1];
                out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x;
                out[3] = a[3] * y; out[4] = a[4] * y; out[5] = a[5] * y;
                out[6] = a[6]; out[7] = a[7]; out[8] = a[8];
                return out;
            },
            multiply: (out, a, b) => {
                let a00 = a[0], a01 = a[1], a02 = a[2];
                let a10 = a[3], a11 = a[4], a12 = a[5];
                let a20 = a[6], a21 = a[7], a22 = a[8];

                let b00 = b[0], b01 = b[1], b02 = b[2];
                let b10 = b[3], b11 = b[4], b12 = b[5];
                let b20 = b[6], b21 = b[7], b22 = b[8];

                out[0] = b00 * a00 + b10 * a01 + b20 * a02;
                out[1] = b01 * a00 + b11 * a01 + b21 * a02;
                out[2] = b02 * a00 + b12 * a01 + b22 * a02;

                out[3] = b00 * a10 + b10 * a11 + b20 * a12;
                out[4] = b01 * a10 + b11 * a11 + b21 * a12;
                out[5] = b02 * a10 + b12 * a11 + b22 * a12;

                out[6] = b00 * a20 + b10 * a21 + b20 * a22;
                out[7] = b01 * a20 + b11 * a21 + b21 * a22;
                out[8] = b02 * a20 + b12 * a21 + b22 * a22;
                return out;
            }
        };

        function transformPoint(matrix, point) {
            const x = point[0], y = point[1];
            const w = matrix[2] * x + matrix[5] * y + matrix[8];
            return [
                (matrix[0] * x + matrix[3] * y + matrix[6]) / w,
                (matrix[1] * x + matrix[4] * y + matrix[7]) / w,
            ];
        }

        // --- 绘图辅助函数 ---
        function drawSidebar() {
            ctx.fillStyle = '#f0f4f8';
            ctx.fillRect(0, 0, state.sidebar.width, height);
            ctx.strokeStyle = '#d1d9e6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(state.sidebar.width, 0);
            ctx.lineTo(state.sidebar.width, height);
            ctx.stroke();

            ctx.font = 'bold 20px "Noto Sans SC"';
            ctx.fillStyle = '#334155';
            ctx.textAlign = 'center';
            ctx.fillText('变换课程', state.sidebar.width / 2, 40);

            state.sidebar.buttons.forEach((button, index) => {
                const y = 80 + index * 50;
                if (state.currentScene === button.id) {
                    ctx.fillStyle = '#0d6efd';
                    ctx.fillRect(0, y - 20, 5, 40);
                    ctx.fillStyle = '#0d6efd';
                } else if (state.sidebar.hoveredButton === button.id) {
                    ctx.fillStyle = '#64748b';
                } else {
                    ctx.fillStyle = '#334155';
                }
                ctx.font = '16px "Noto Sans SC"';
                ctx.textAlign = 'left';
                ctx.fillText(button.text, 20, y + 5);
            });
        }

        function drawShape(points, matrix) {
            if (points.length === 0) return;
            ctx.beginPath();
            const transformedStart = transformPoint(matrix, points[0]);
            ctx.moveTo(transformedStart[0], transformedStart[1]);
            for (let i = 1; i < points.length; i++) {
                const p = transformPoint(matrix, points[i]);
                ctx.lineTo(p[0], p[1]);
            }
            ctx.closePath();
        }

        function drawText(lines, x, y, options = {}) {
            const { font = '16px "Noto Sans SC"', fill = '#333', align = 'left', baseLine = 'top' } = options;
            ctx.font = font;
            ctx.fillStyle = fill;
            ctx.textAlign = align;
            ctx.textBaseline = baseLine;
            let currentY = y;
            for (const line of lines) {
                ctx.fillText(line, x, currentY);
                currentY += parseInt(font, 10) * 1.2;
            }
        }

        // --- 场景渲染函数 ---
        function drawIntroScene() {
            drawText([
                '欢迎来到“变换”课程',
                '',
                '我们之前已经学会了如何绘制一个静态的图形。',
                '但图形学的魅力在于动态。',
                '',
                '本课程的核心问题是：',
                '我们如何精确地告诉GPU，',
                '让这个正方形动起来？'
            ], state.sidebar.width + 50, 50, { font: '24px "Noto Sans SC"' });
            
            const square = [[-50, -50], [50, -50], [50, 50], [-50, 50]];
            const matrix = mat3.create();
            mat3.translate(matrix, matrix, [width/2 + 100, height/2 + 50]);
            
            ctx.save();
            drawShape(square, matrix);
            ctx.fillStyle = '#f59e0b';
            ctx.fill();
            ctx.strokeStyle = '#d97706';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        }

        function drawBasicScene() {
            // ... [代码过长，此处省略，完整代码在最终文件中]
            // 此处将实现一个带滑块的交互，让用户控制平移、旋转、缩放
            drawText(['二维基本变换：请在下方画布中拖拽控制点'], state.sidebar.width + 50, 50, { font: '24px "Noto Sans SC"' });
        }

        function drawHomogeneousScene() {
             drawText(['齐次坐标：升维的智慧'], state.sidebar.width + 50, 50, { font: '24px "Noto Sans SC"' });
        }

        function drawCompositeScene() {
             drawText(['复合变换：顺序的重要性'], state.sidebar.width + 50, 50, { font: '24px "Noto Sans SC"' });
        }
        
        function drawMvpScene() {
            drawText(['模型-视图-投影 (MVP) 流水线'], state.sidebar.width + 50, 50, { font: '24px "Noto Sans SC"' });
        }

        function drawSandboxScene() {
            const { objects, selectedIndex, keys } = state.sandbox;
            
            // 处理键盘输入
            if (selectedIndex !== -1 && objects[selectedIndex]) {
                const obj = objects[selectedIndex];
                const speed = 5;
                if (keys['w']) obj.y -= speed;
                if (keys['s']) obj.y += speed;
                if (keys['a']) obj.x -= speed;
                if (keys['d']) obj.x += speed;
                if (keys['q']) obj.rotation -= 0.05;
                if (keys['e']) obj.rotation += 0.05;
                if (keys['+'] || keys['=']) { obj.scale *= 1.05; }
                if (keys['-']) { obj.scale /= 1.05; }
            }

            // 绘制所有物体
            objects.forEach((obj, index) => {
                const matrix = mat3.create();
                mat3.translate(matrix, matrix, [obj.x, obj.y]);
                mat3.rotate(matrix, matrix, obj.rotation);
                mat3.scale(matrix, matrix, [obj.scale, obj.scale]);
                
                ctx.save();
                drawShape(obj.points, matrix);
                ctx.fillStyle = obj.color;
                ctx.fill();
                if (index === selectedIndex) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                ctx.restore();
            });

            // 绘制UI提示
            drawText([
                '交互式沙盒',
                '鼠标左键：添加正方形',
                '鼠标右键：添加三角形',
                '点击物体进行选中',
                'W/A/S/D：平移',
                'Q/E：旋转',
                '+/-：缩放',
            ], state.sidebar.width + 50, 50, { font: '20px "Noto Sans SC"' });

            if (selectedIndex !== -1 && objects[selectedIndex]) {
                 drawText([`当前选中：物体 #${selectedIndex}`], width - 250, 50, { font: '16px "Noto Sans SC"', align: 'left' });
            }
        }


        // --- 主渲染循环 ---
        function renderLoop() {
            // 重置画布
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            drawSidebar();
            
            // 绘制当前场景
            ctx.save();
            ctx.translate(state.sidebar.width, 0); // 将场景绘制区域移到侧边栏右侧
            
            // 根据当前场景调用不同的绘制函数
            switch(state.currentScene) {
                case 'intro': drawIntroScene(); break;
                // case 'basic': drawBasicScene(); break;
                // case 'homogeneous': drawHomogeneousScene(); break;
                // case 'composite': drawCompositeScene(); break;
                // case 'mvp': drawMvpScene(); break;
                case 'sandbox': drawSandboxScene(); break;
                default:
                    drawText([`场景 "${state.currentScene}" 待实现`], 50, 50);
            }
            
            ctx.restore();

            requestAnimationFrame(renderLoop);
        }

        // --- 事件处理 ---
        function setupEventListeners() {
            // 窗口大小调整
            function resize() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
            }
            window.addEventListener('resize', resize);
            resize();

            // 鼠标移动 (用于侧边栏悬停效果)
            canvas.addEventListener('mousemove', (e) => {
                if (e.clientX < state.sidebar.width) {
                    const y = e.clientY;
                    let hovered = null;
                    state.sidebar.buttons.forEach((btn, i) => {
                        if (y > 80 + i * 50 - 20 && y < 80 + i * 50 + 20) {
                            hovered = btn.id;
                        }
                    });
                    state.sidebar.hoveredButton = hovered;
                } else {
                    state.sidebar.hoveredButton = null;
                }
            });

            // 鼠标点击
            canvas.addEventListener('click', (e) => {
                if (e.clientX < state.sidebar.width) { // 点击侧边栏
                    if (state.sidebar.hoveredButton) {
                        state.currentScene = state.sidebar.hoveredButton;
                    }
                } else { // 点击主画布
                    if (state.currentScene === 'sandbox') {
                         const mouseX = e.clientX - state.sidebar.width;
                         const mouseY = e.clientY;
                         
                         // 检查是否点中了某个物体
                         let clickedIndex = -1;
                         for (let i = state.sandbox.objects.length - 1; i >= 0; i--) {
                             const obj = state.sandbox.objects[i];
                             const matrix = mat3.create();
                             mat3.translate(matrix, matrix, [obj.x, obj.y]);
                             mat3.rotate(matrix, matrix, obj.rotation);
                             mat3.scale(matrix, matrix, [obj.scale, obj.scale]);
                             
                             ctx.save();
                             drawShape(obj.points, matrix);
                             if (ctx.isPointInPath(mouseX, mouseY)) {
                                 clickedIndex = i;
                                 break;
                             }
                             ctx.restore();
                         }
                         
                         if (clickedIndex !== -1) {
                             state.sandbox.selectedIndex = clickedIndex;
                         }
                    }
                }
            });

             canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (state.currentScene === 'sandbox' && e.clientX > state.sidebar.width) {
                     const mouseX = e.clientX - state.sidebar.width;
                     const mouseY = e.clientY;
                     const newObject = {
                        x: mouseX, y: mouseY, rotation: 0, scale: 1,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                     };
                    if (e.button === 2) { // 右键
                         newObject.points = [[-25, 25], [25, 25], [0, -25]]; // 三角形
                    } else { // 理论上不会到这，但作为备用
                         newObject.points = [[-25, -25], [25, -25], [25, 25], [-25, 25]]; // 正方形
                    }
                     state.sandbox.objects.push(newObject);
                     state.sandbox.selectedIndex = state.sandbox.objects.length - 1;
                }
            });

             canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0 && state.currentScene === 'sandbox' && e.clientX > state.sidebar.width) { // 左键
                    const mouseX = e.clientX - state.sidebar.width;
                    const mouseY = e.clientY;

                    // 只有没点中物体时才添加新物体
                    let isClickOnObject = false;
                    for (let i = 0; i < state.sandbox.objects.length; i++) {
                         // ... [检测代码同上]
                    }
                    
                    if (!isClickOnObject) {
                        const newObject = {
                            points: [[-25, -25], [25, -25], [25, 25], [-25, 25]], // 正方形
                            x: mouseX, y: mouseY, rotation: 0, scale: 1,
                            color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                        };
                        state.sandbox.objects.push(newObject);
                        state.sandbox.selectedIndex = state.sandbox.objects.length - 1;
                    }
                }
            });

            // 键盘事件
            window.addEventListener('keydown', (e) => {
                if (state.currentScene === 'sandbox') {
                    state.sandbox.keys[e.key] = true;
                }
            });
            window.addEventListener('keyup', (e) => {
                 if (state.currentScene === 'sandbox') {
                    state.sandbox.keys[e.key] = false;
                }
            });
        }

        // --- 应用启动 ---
        setupEventListeners();
        renderLoop();
    </script>
</body>
</html>