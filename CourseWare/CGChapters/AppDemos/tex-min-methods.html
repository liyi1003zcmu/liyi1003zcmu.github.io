<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>纹理缩小演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 使用 Tailwind 'Inter' 字体 */
        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #f8fafc; /* gray-50 */
            color: #1f2937; /* gray-800 */
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        header {
            background-color: #ffffff;
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
            padding: 0.75rem 1.5rem;
            flex-shrink: 0;
            z-index: 20;
        }
        .app-layout {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #controls {
            width: 320px;
            flex-shrink: 0;
            background-color: #ffffff;
            border-right: 1px solid #e5e7eb; /* gray-200 */
            overflow-y: auto;
            padding: 1rem;
            z-index: 10;
        }
        #viewport-container {
            flex-grow: 1;
            position: relative;
            background-color: #374151; /* gray-700 */
            overflow: hidden;
        }
        #webgl-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #split-slider {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 8px;
            background-color: rgba(3, 105, 161, 0.7); /* cyan-700 with opacity */
            cursor: col-resize;
            z-index: 5;
            border-left: 2px solid rgba(255, 255, 255, 0.5);
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            transform: translateX(-50%); /* Center the 8px bar */
        }
        #split-slider:hover {
            background-color: #0e7490; /* cyan-600 */
        }
        #fps-display {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 2px 6px;
            font-size: 0.75rem;
            border-radius: 4px;
            z-index: 5;
        }
        #learning-panel {
            flex-shrink: 0;
            background-color: #f9fafb; /* gray-50 */
            border-top: 1px solid #e5e7eb; /* gray-200 */
            max-height: 25vh;
            overflow-y: auto;
            padding: 1rem 1.5rem;
            z-index: 20;
        }
        /* 自定义表单控件样式 */
        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151; /* gray-700 */
            margin-bottom: 0.25rem;
        }
        .form-select, .form-input, .form-file {
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.25rem;
            color: #1f2937; /* gray-800 */
            background-color: #ffffff;
            border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        .form-select:focus, .form-input:focus, .form-file:focus {
            border-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25); /* blue-600 with focus ring */
            outline: none;
        }
        .form-file {
            padding: 0.375rem;
        }
        .form-range {
            width: 100%;
            accent-color: #2563eb; /* blue-600 */
        }
        .control-group {
            margin-bottom: 1.25rem;
            padding-bottom: 1.25rem;
            border-bottom: 1px solid #e5e7eb; /* gray-200 */
        }
        .control-group:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        .btn {
            display: inline-block;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            line-height: 1.25rem;
            color: white;
            background-color: #2563eb; /* blue-600 */
            border: 1px solid transparent;
            border-radius: 0.375rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }
        .btn:hover {
            background-color: #1d4ed8; /* blue-700 */
        }
        .btn-secondary {
            background-color: #4b5563; /* gray-600 */
        }
        .btn-secondary:hover {
            background-color: #374151; /* gray-700 */
        }
        .btn-full {
            width: 100%;
        }
        .grid-cols-2 {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.75rem;
        }
    </style>
</head>
<body class="h-screen flex flex-col">

    <!-- 1. 顶部栏 -->
    <header class="shadow-sm">
        <h1 class="text-xl font-semibold text-gray-900">纹理缩小（Texture Minification）演示</h1>
        <p class="text-sm text-gray-600">对比 Nearest, Linear, Mipmap 和 Anisotropic 过滤在纹理缩小时的效果。</p>
    </header>

    <!-- 2. 主布局 (控制面板 + 视口) -->
    <main class="app-layout">
        
        <!-- 3. 左侧控制面板 -->
        <nav id="controls">
            <!-- 纹理源 -->
            <div class="control-group">
                <label for="texture-source" class="form-label">纹理源</label>
                <select id="texture-source" class="form-select mb-2">
                    <option value="checkerboard-32">棋盘格 (32x32)</option>
                    <option value="checkerboard-128">棋盘格 (128x128)</option>
                    <option value="stripes-h">水平条纹 (高频)</option>
                    <option value="stripes-v">垂直条纹 (高频)</option>
                    <option value="stripes-diag">倾斜条纹 (45°)</option>
                    <option value="radial-rings">同心圆</option>
                    <option value="pixel-font">点阵字体</option>
                    <option value="noise">柏林噪声</option>
                    <option value="brick">砖墙 (照片)</option>
                </select>
                <label for="texture-upload" class="form-label mt-2">... 或上传图片</label>
                <input type="file" id="texture-upload" class="form-file" accept="image/png, image/jpeg, image/webp">
            </div>

            <!-- 过滤方法对比 -->
            <div class="control-group">
                <div class="grid-cols-2">
                    <div>
                        <label for="filter-a" class="form-label">左侧 (A)</label>
                        <select id="filter-a" class="form-select">
                            <option value="nearest">Nearest (最近邻)</option>
                            <option value="linear">Linear (双线性)</option>
                            <option value="mipmap_nearest">Mipmap Nearest</option>
                            <option value="mipmap_linear" selected>Mipmap Linear (三线性)</option>
                            <option value="anisotropic">Anisotropic (各向异性)</option>
                        </select>
                    </div>
                    <div>
                        <label for="filter-b" class="form-label">右侧 (B)</label>
                        <select id="filter-b" class="form-select">
                            <option value="nearest">Nearest (最近邻)</option>
                            <option value="linear" selected>Linear (双线性)</option>
                            <option value="mipmap_nearest">Mipmap Nearest</option>
                            <option value="mipmap_linear">Mipmap Linear (三线性)</option>
                            <option value="anisotropic">Anisotropic (各向异性)</option>
                        </select>
                    </div>
                </div>
                <label for="anisotropy-level" class="form-label mt-3">各向异性等级</label>
                <select id="anisotropy-level" class="form-select" disabled>
                    <option value="1">1x (不可用)</option>
                </select>
            </div>

            <!-- 变换参数 -->
            <div class="control-group">
                <label for="scale" class="form-label">缩放 (Scale): <span id="scale-value">0.40</span></label>
                <input type="range" id="scale" class="form-range" min="0.05" max="1.5" step="0.01" value="0.4">
                
                <label for="rotation" class="form-label mt-3">平面旋转 (Rotation): <span id="rotation-value">0</span>°</label>
                <input type="range" id="rotation" class="form-range" min="-90" max="90" step="1" value="0">
                
                <label for="tilt" class="form-label mt-3">透视倾斜 (Tilt): <span id="tilt-value">30</span>°</label>
                <input type="range" id="tilt" class="form-range" min="0" max="85" step="1" value="30">
                
                <label for="projection" class="form-label mt-3">投影</label>
                <select id="projection" class="form-select">
                    <option value="orthographic">正交 (Orthographic)</option>
                    <option value="perspective" selected>透视 (Perspective)</option>
                </select>
            </div>

            <!-- 调试与重置 -->
            <div class="control-group">
                <label for="debug-overlay" class="form-label">调试叠加</label>
                <select id="debug-overlay" class="form-select">
                    <option value="none">无</option>
                    <option value="mipmap_lod" selected>Mipmap LOD 热力图</option>
                </select>
                
                <div class="mt-4 grid-cols-2">
                    <button id="reset-view" class="btn btn-secondary">重置视图</button>
                    <button id="swap-filters" class="btn btn-secondary">交换A/B</button>
                </div>
                <button id="aniso-scene" class="btn btn-full mt-3">各向异性优势场景</button>
            </div>
        </nav>

        <!-- 4. 主视图区 -->
        <div id="viewport-container">
            <canvas id="webgl-canvas"></canvas>
            <div id="split-slider" style="left: 50%;"></div>
            <div id="fps-display">FPS: --</div>
        </div>

    </main>

    <!-- 5. 底部教学模块 -->
    <footer id="learning-panel">
        <h4 class="font-semibold text-gray-800">教学信息</h4>
        <p class="text-sm text-gray-600 mt-1">
            <strong>纹理缩小 (Minification):</strong> 当一个纹理像素（Texel）在屏幕上覆盖的区域小于一个屏幕像素时，就需要缩小。
        </p>
        <ul class="text-sm text-gray-600 list-disc list-inside mt-2 space-y-1">
            <li><strong>Nearest:</strong> 选择最近的纹理像素。速度快，但在缩小时产生严重锯齿和闪烁 (Aliasing)。</li>
            <li><strong>Linear (Bilinear):</strong> 线性插值4个最近的纹理像素。比 Nearest 平滑，但仍会产生摩尔纹 (Moiré) 和闪烁。</li>
            <li><strong>Mipmap:</strong> 预先计算一系列缩小版本的纹理（Mipmap 层）。渲染时根据缩放程度选择合适的层。</li>
            <li><strong>Mipmap Linear (Trilinear):</strong> 在最近的两个 Mipmap 层上分别进行 Bilinear 采样，然后再对这两个结果进行线性插值。能有效消除摩尔纹，但会导致过度模糊。</li>
            <li><strong>Anisotropic (各向异性):</strong> 当视线与纹理表面倾斜时，一个屏幕像素可能对应纹理空间中一个被拉长的矩形（足迹）。Trilinear 仅使用方形采样，导致模糊。各向异性过滤会沿着拉长的方向进行多次采样，保留更多细节。</li>
        </ul>
    </footer>

    <!-- 
    ====================================================================
    着色器
    ====================================================================
    -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;

        uniform mat4 u_projectionMatrix;
        uniform mat4 u_modelViewMatrix;

        varying vec2 v_texCoord;

        void main() {
            gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        // WebGL 1.0 需要手动开启
        #extension GL_OES_standard_derivatives : enable

        precision mediump float;

        varying vec2 v_texCoord;
        
        // 我们使用两个纹理单元，分别绑定配置了A/B过滤器的纹理
        uniform sampler2D u_texture_A;
        uniform sampler2D u_texture_B;

        // 控制参数
        uniform float u_splitPosition_px; // 分割线的屏幕像素X坐标
        uniform float u_debugMode; // 0.0 = off, 1.0 = LOD heatmap
        uniform vec2 u_textureSize; // 纹理分辨率

        // LOD 热力图颜色
        vec3 heatmapColor(float t) {
            t = clamp(t, 0.0, 8.0) / 8.0; // 假设我们关心 0-8 级 LOD
            return mix(
                vec3(0.0, 0.0, 1.0), // Blue
                mix(
                    vec3(0.0, 1.0, 0.0), // Green
                    vec3(1.0, 0.0, 0.0), // Red
                    smoothstep(0.5, 1.0, t)
                ),
                smoothstep(0.0, 0.5, t)
            );
        }
        
        // 计算LOD (基于 dFdx/dFdy)
        float calculateLOD() {
            // dFdx/dFdy 计算纹理坐标在屏幕空间X/Y方向的变化
            // 乘以纹理尺寸，得到 texel 空间的变化
            vec2 dx = dFdx(v_texCoord * u_textureSize);
            vec2 dy = dFdy(v_texCoord * u_textureSize);
            
            // 像素足迹的近似长度
            float px = dot(dx, dx);
            float py = dot(dy, dy);
            
            // 取最大变化，计算 log2
            float lod = 0.5 * log2(max(px, py));
            return max(0.0, lod); // LOD 不应小于0
        }

        void main() {
            // 从两个纹理单元采样
            vec4 colorA = texture2D(u_texture_A, v_texCoord);
            vec4 colorB = texture2D(u_texture_B, v_texCoord);
            
            vec4 finalColor;
            
            // 根据分割线位置选择
            // 我们在分割线处使用 2px 的平滑过渡，避免锯齿
            float mixFactor = smoothstep(
                u_splitPosition_px - 1.0, 
                u_splitPosition_px + 1.0, 
                gl_FragCoord.x
            );
            finalColor = mix(colorA, colorB, mixFactor);

            // 调试模式
            if (u_debugMode > 0.5) {
                float lod = calculateLOD();
                vec3 heatmap = heatmapColor(lod);
                
                // 根据分割线选择不同的LOD（虽然它们应该几乎一样）
                // 主要是为了保持分屏效果
                finalColor = mix(
                    vec4(heatmap * colorA.a + colorA.rgb * (1.0 - colorA.a), 1.0), // 混合热力图和纹理
                    vec4(heatmap * colorB.a + colorB.rgb * (1.0 - colorB.a), 1.0),
                    mixFactor
                );
            }

            gl_FragColor = finalColor;
        }
    </script>

    <!-- 
    ====================================================================
    JavaScript (模块化)
    ====================================================================
    -->
    <script type="module">
        //==================================
        // 1. WebGL 辅助函数 (webgl-utils.js)
        //==================================
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(`Error compiling shader: ${gl.getShaderInfoLog(shader)}`);
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(`Error linking program: ${gl.getProgramInfoLog(program)}`);
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        //==================================
        // 2. 矩阵数学库 (mat4.js)
        //==================================
        const mat4 = {
            create: () => new Float32Array(16),
            identity: (out) => {
                out.fill(0);
                out[0] = out[5] = out[10] = out[15] = 1;
                return out;
            },
            multiply: (out, a, b) => {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
            },
            perspective: (out, fov, aspect, near, far) => {
                const f = 1.0 / Math.tan(fov / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[11] = -1;
                out[15] = 0;
                if (far != null && far !== Infinity) {
                    const nf = 1 / (near - far);
                    out[10] = (far + near) * nf;
                    out[14] = (2 * far * near) * nf;
                } else {
                    out[10] = -1;
                    out[14] = -2 * near;
                }
                return out;
            },
            ortho: (out, left, right, bottom, top, near, far) => {
                const lr = 1 / (left - right);
                const bt = 1 / (bottom - top);
                const nf = 1 / (near - far);
                out[0] = -2 * lr;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = -2 * bt;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 2 * nf;
                out[11] = 0;
                out[12] = (left + right) * lr;
                out[13] = (top + bottom) * bt;
                out[14] = (far + near) * nf;
                out[15] = 1;
                return out;
            },
            translate: (out, a, v) => {
                let x = v[0], y = v[1], z = v[2];
                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    // ... (omitted for brevity, we'll use in-place)
                    mat4.identity(out); // Assume we start from identity or existing matrix
                    out[12] = v[0]; out[13] = v[1]; out[14] = v[2];
                }
                return out;
            },
            scale: (out, a, v) => {
                let x = v[0], y = v[1], z = v[2];
                out[0] = a[0] * x;
                out[1] = a[1] * x;
                out[2] = a[2] * x;
                out[3] = a[3] * x;
                out[4] = a[4] * y;
                out[5] = a[5] * y;
                out[6] = a[6] * y;
                out[7] = a[7] * y;
                out[8] = a[8] * z;
                out[9] = a[9] * z;
                out[10] = a[10] * z;
                out[11] = a[11] * z;
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            },
            rotateX: (out, a, rad) => {
                let s = Math.sin(rad), c = Math.cos(rad);
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                return out;
            },
            rotateZ: (out, a, rad) => {
                let s = Math.sin(rad), c = Math.cos(rad);
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                if (a !== out) {
                    out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                out[0] = a00 * c + a10 * s;
                out[1] = a01 * c + a11 * s;
                out[2] = a02 * c + a12 * s;
                out[3] = a03 * c + a13 * s;
                out[4] = a10 * c - a00 * s;
                out[5] = a11 * c - a01 * s;
                out[6] = a12 * c - a02 * s;
                out[7] = a13 * c - a03 * s;
                return out;
            }
        };

        //==================================
        // 3. 纹理生成器 (textures.js)
        //==================================
        const textureGenerator = {
            // 返回 { data: Uint8Array, width: number, height: number }
            generate(type, size = 1024) {
                switch (type) {
                    case 'checkerboard-32':
                        return this.checkerboard(size, size, 32);
                    case 'checkerboard-128':
                        return this.checkerboard(size, size, 128);
                    case 'stripes-h':
                        return this.stripes(size, size, 8, 0); // 8px H-stripes
                    case 'stripes-v':
                        return this.stripes(size, size, 8, 90); // 8px V-stripes
                    case 'stripes-diag':
                        return this.stripes(size, size, 16, 45); // 16px Diag-stripes
                    case 'radial-rings':
                        return this.radial(size, size, 32);
                    case 'pixel-font':
                        return this.pixelFont(size, size);
                    case 'noise':
                        return this.noise(size, size);
                    case 'brick':
                        // 这是一个内置的位图，模拟照片
                        return this.brick(size, size);
                    default:
                        return this.checkerboard(size, size, 32);
                }
            },

            checkerboard(width, height, freq) {
                const data = new Uint8Array(width * height * 4);
                const checkSize = width / freq;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const c = (Math.floor(x / checkSize) + Math.floor(y / checkSize)) % 2;
                        const val = c === 0 ? 200 : 80;
                        data[i] = val;
                        data[i + 1] = val;
                        data[i + 2] = val;
                        data[i + 3] = 255;
                    }
                }
                return { data, width, height };
            },

            stripes(width, height, freq, angleDeg) {
                const data = new Uint8Array(width * height * 4);
                const rad = angleDeg * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                const period = width / freq;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        // 旋转坐标系
                        const x_rot = x * cos + y * sin;
                        const c = Math.floor(x_rot / period) % 2;
                        const val = c === 0 ? 255 : 0;
                        data[i] = val;
                        data[i + 1] = val;
                        data[i + 2] = val;
                        data[i + 3] = 255;
                    }
                }
                return { data, width, height };
            },

            radial(width, height, freq) {
                const data = new Uint8Array(width * height * 4);
                const cx = width / 2;
                const cy = height / 2;
                const period = width / (freq * 2); // 32 rings
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const dx = x - cx;
                        const dy = y - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const c = Math.floor(dist / period) % 2;
                        const val = c === 0 ? 220 : 30;
                        data[i] = val;
                        data[i + 1] = val;
                        data[i + 2] = val;
                        data[i + 3] = 255;
                    }
                }
                return { data, width, height };
            },
            
            pixelFont(width, height) {
                const data = new Uint8Array(width * height * 4);
                // 简单的 'A' 5x7 字体
                const font = [
                    0b01110,
                    0b10001,
                    0b10001,
                    0b11111,
                    0b10001,
                    0b10001,
                    0b10001
                ];
                const charSize = 8;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        const charX = x % charSize;
                        const charY = y % charSize;
                        let val = 0;
                        if (charX < 5 && charY < 7) {
                            if ((font[charY] >> (4 - charX)) & 1) {
                                val = 255;
                            }
                        }
                        data[i] = val; data[i+1] = val; data[i+2] = val; data[i+3] = 255;
                    }
                }
                return { data, width, height };
            },

            noise(width, height) {
                // 简单的 value noise
                const data = new Uint8Array(width * height * 4);
                const perm = new Array(512);
                for(let i=0; i<256; i++) perm[i] = perm[i+256] = Math.floor(Math.random() * 256);
                const rand = (i) => perm[i % 512] / 255.0;
                
                const interp = (a, b, t) => (b - a) * (3 * t * t - 2 * t * t * t) + a;

                const freq = 16.0 / width;
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        
                        const fx = x * freq;
                        const fy = y * freq;
                        const ix = Math.floor(fx);
                        const iy = Math.floor(fy);
                        const tx = fx - ix;
                        const ty = fy - iy;

                        const r00 = rand(ix + rand(iy));
                        const r10 = rand(ix + 1 + rand(iy));
                        const r01 = rand(ix + rand(iy + 1));
                        const r11 = rand(ix + 1 + rand(iy + 1));
                        
                        const v = interp(interp(r00, r10, tx), interp(r01, r11, tx), ty);
                        const val = Math.floor(v * 255);
                        data[i] = val; data[i+1] = val; data[i+2] = val; data[i+3] = 255;
                    }
                }
                return { data, width, height };
            },

            brick(width, height) {
                // 程序化生成一个砖墙
                const data = new Uint8Array(width * height * 4);
                const brickH = height / 20;
                const brickW = width / 10;
                const mortar = 4; // 砂浆厚度 (px)
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const i = (y * width + x) * 4;
                        
                        const row = Math.floor(y / brickH);
                        const y_in = y % brickH;
                        
                        let x_eff = x;
                        if (row % 2 === 1) {
                            x_eff += brickW / 2; // 行偏移
                        }
                        const x_in = x_eff % brickW;

                        if (y_in < mortar || x_in < mortar) {
                            // 砂浆
                            data[i] = 180; data[i+1] = 180; data[i+2] = 180;
                        } else {
                            // 砖块 (带一点随机色)
                            const noise = (x * 0.1 + y * 0.3) % 1;
                            data[i] = 180 + noise * 30;
                            data[i+1] = 80 + noise * 10;
                            data[i+2] = 50 + noise * 5;
                        }
                        data[i+3] = 255;
                    }
                }
                return { data, width, height };
            }
        };

        //==================================
        // 4. 主应用 (main.js)
        //==================================
        
        // --- 全局状态 ---
        
        /** @type {HTMLCanvasElement} */
        let canvas;
        /** @type {WebGLRenderingContext} */
        let gl;
        
        // GL 对象
        const glObjects = {
            program: null,
            locations: {},
            buffers: {
                position: null,
                texCoord: null,
                indices: null,
            },
            textures: {
                sourceData: null, // { data, width, height }
                texA: null, // GL texture A
                texB: null, // GL texture B
            },
            extensions: {
                aniso: null,
                derivatives: null,
            },
            maxAniso: 1,
        };

        // UI 状态
        const state = {
            filterA: "mipmap_linear",
            filterB: "linear",
            anisotropyLevel: 1,
            textureSource: "checkerboard-32",
            textureSize: 1024,
            scale: 0.4,
            rotation: 0,
            tilt: 30,
            projection: "perspective",
            debugMode: 1, // 0=none, 1=lod
            splitPosition: 0.5, // 0.0 to 1.0
            isDragging: false,
        };
        
        // 变换矩阵
        const matrices = {
            projection: mat4.create(),
            modelView: mat4.create(),
        };

        // 性能
        let lastTime = 0;
        let frameCount = 0;
        let fps = 0;

        // --- DOM 元素 ---
        const ui = {};

        // --- 初始化 ---
        
        document.addEventListener('DOMContentLoaded', main);

        function main() {
            canvas = document.getElementById('webgl-canvas');
            ui.fpsDisplay = document.getElementById('fps-display');
            
            try {
                gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) throw new Error('WebGL not supported');
            } catch (e) {
                alert(e.message);
                return;
            }

            initExtensions();
            initShaders();
            initBuffers();
            initTextures();
            initUI();
            initSplitSlider();

            // 设置默认场景
            applyStateToUI();
            updateApp();

            // 开始渲染
            lastTime = performance.now();
            requestAnimationFrame(renderLoop);
        }

        function initExtensions() {
            glObjects.extensions.derivatives = gl.getExtension('OES_standard_derivatives');
            if (!glObjects.extensions.derivatives) {
                console.warn("OES_standard_derivatives not supported. LOD heatmap disabled.");
            }

            glObjects.extensions.aniso = 
                gl.getExtension('EXT_texture_filter_anisotropic') ||
                gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');

            if (glObjects.extensions.aniso) {
                glObjects.maxAniso = gl.getParameter(glObjects.extensions.aniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
                console.warn("EXT_texture_filter_anisotropic not supported. Anisotropic filtering disabled.");
            }
        }
        
        function initShaders() {
            const vsSource = document.getElementById('vertex-shader').text;
            const fsSource = document.getElementById('fragment-shader').text;

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            
            glObjects.program = createProgram(gl, vertexShader, fragmentShader);
            gl.useProgram(glObjects.program);
            
            glObjects.locations = {
                // Attributes
                a_position: gl.getAttribLocation(glObjects.program, 'a_position'),
                a_texCoord: gl.getAttribLocation(glObjects.program, 'a_texCoord'),
                // Uniforms
                u_projectionMatrix: gl.getUniformLocation(glObjects.program, 'u_projectionMatrix'),
                u_modelViewMatrix: gl.getUniformLocation(glObjects.program, 'u_modelViewMatrix'),
                u_texture_A: gl.getUniformLocation(glObjects.program, 'u_texture_A'),
                u_texture_B: gl.getUniformLocation(glObjects.program, 'u_texture_B'),
                u_splitPosition_px: gl.getUniformLocation(glObjects.program, 'u_splitPosition_px'),
                u_debugMode: gl.getUniformLocation(glObjects.program, 'u_debugMode'),
                u_textureSize: gl.getUniformLocation(glObjects.program, 'u_textureSize'),
            };
        }

        function initBuffers() {
            // 一个 -1 到 1 的四边形
            const positions = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
            const texCoords = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
            const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);

            glObjects.buffers.position = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, glObjects.buffers.position);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            glObjects.buffers.texCoord = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, glObjects.buffers.texCoord);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            glObjects.buffers.indices = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glObjects.buffers.indices);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

            // 设置属性指针
            gl.bindBuffer(gl.ARRAY_BUFFER, glObjects.buffers.position);
            gl.vertexAttribPointer(glObjects.locations.a_position, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(glObjects.locations.a_position);

            gl.bindBuffer(gl.ARRAY_BUFFER, glObjects.buffers.texCoord);
            gl.vertexAttribPointer(glObjects.locations.a_texCoord, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(glObjects.locations.a_texCoord);
        }

        function initTextures() {
            glObjects.textures.texA = gl.createTexture();
            glObjects.textures.texB = gl.createTexture();
            
            // 加载默认纹理
            loadSourceTexture(state.textureSource);
        }

        function initUI() {
            // 缓存所有UI元素
            ui.textureSource = document.getElementById('texture-source');
            ui.textureUpload = document.getElementById('texture-upload');
            ui.filterA = document.getElementById('filter-a');
            ui.filterB = document.getElementById('filter-b');
            ui.anisotropyLevel = document.getElementById('anisotropy-level');
            ui.scale = document.getElementById('scale');
            ui.scaleValue = document.getElementById('scale-value');
            ui.rotation = document.getElementById('rotation');
            ui.rotationValue = document.getElementById('rotation-value');
            ui.tilt = document.getElementById('tilt');
            ui.tiltValue = document.getElementById('tilt-value');
            ui.projection = document.getElementById('projection');
            ui.debugOverlay = document.getElementById('debug-overlay');
            ui.resetView = document.getElementById('reset-view');
            ui.swapFilters = document.getElementById('swap-filters');
            ui.anisoScene = document.getElementById('aniso-scene');

            // 填充各向异性选项
            if (glObjects.extensions.aniso) {
                ui.anisotropyLevel.innerHTML = '';
                for (let i = 1; i <= glObjects.maxAniso; i *= 2) {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = `${i}x`;
                    ui.anisotropyLevel.add(opt);
                }
                ui.anisotropyLevel.value = Math.min(8, glObjects.maxAniso); // 默认 8x
                state.anisotropyLevel = ui.anisotropyLevel.value;
            } else {
                // 禁用 Anisotropic 选项
                Array.from(ui.filterA.options).concat(Array.from(ui.filterB.options)).forEach(opt => {
                    if (opt.value === 'anisotropic') opt.disabled = true;
                });
            }

            // 绑定事件
            ui.textureSource.addEventListener('change', e => {
                state.textureSource = e.target.value;
                loadSourceTexture(state.textureSource);
                updateApp();
            });
            ui.textureUpload.addEventListener('change', handleFileUpload);
            
            ui.filterA.addEventListener('change', e => { state.filterA = e.target.value; updateApp(); });
            ui.filterB.addEventListener('change', e => { state.filterB = e.target.value; updateApp(); });
            ui.anisotropyLevel.addEventListener('change', e => { state.anisotropyLevel = parseInt(e.target.value); updateApp(); });

            ui.scale.addEventListener('input', e => { 
                state.scale = parseFloat(e.target.value); 
                ui.scaleValue.textContent = state.scale.toFixed(2);
                updateApp();
            });
            ui.rotation.addEventListener('input', e => { 
                state.rotation = parseFloat(e.target.value); 
                ui.rotationValue.textContent = state.rotation.toFixed(0);
                updateApp();
            });
            ui.tilt.addEventListener('input', e => { 
                state.tilt = parseFloat(e.target.value); 
                ui.tiltValue.textContent = state.tilt.toFixed(0);
                updateApp();
            });
            
            ui.projection.addEventListener('change', e => { state.projection = e.target.value; updateApp(); });
            ui.debugOverlay.addEventListener('change', e => { 
                state.debugMode = (e.target.value === 'mipmap_lod' && glObjects.extensions.derivatives) ? 1.0 : 0.0;
                updateApp();
            });

            // 按钮
            ui.resetView.addEventListener('click', () => {
                state.scale = 0.4;
                state.rotation = 0;
                state.tilt = 30;
                applyStateToUI();
                updateApp();
            });
            
            ui.swapFilters.addEventListener('click', () => {
                [state.filterA, state.filterB] = [state.filterB, state.filterA];
                applyStateToUI();
                updateApp();
            });

            ui.anisoScene.addEventListener('click', () => {
                state.textureSource = "stripes-h";
                state.filterA = "mipmap_linear";
                state.filterB = "anisotropic";
                state.scale = 0.25;
                state.rotation = 0;
                state.tilt = 60;
                state.projection = "perspective";
                state.anisotropyLevel = Math.min(8, glObjects.maxAniso);
                loadSourceTexture(state.textureSource);
                applyStateToUI();
                updateApp();
            });
        }
        
        function initSplitSlider() {
            const slider = document.getElementById('split-slider');
            const container = document.getElementById('viewport-container');

            const onMove = (e) => {
                if (!state.isDragging) return;
                const rect = container.getBoundingClientRect();
                let x = (e.clientX || e.touches[0].clientX) - rect.left;
                state.splitPosition = Math.max(0, Math.min(1, x / rect.width));
                slider.style.left = `${state.splitPosition * 100}%`;
                // 不需要调用 updateApp，因为这是在 renderLoop 中实时读取的
            };

            const onEnd = () => {
                state.isDragging = false;
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('touchmove', onMove);
                window.removeEventListener('mouseup', onEnd);
                window.removeEventListener('touchend', onEnd);
            };

            const onStart = (e) => {
                e.preventDefault();
                state.isDragging = true;
                window.addEventListener('mousemove', onMove);
                window.addEventListener('touchmove', onMove);
                window.addEventListener('mouseup', onEnd);
                window.addEventListener('touchend', onEnd);
            };

            slider.addEventListener('mousedown', onStart);
            slider.addEventListener('touchstart', onStart);
        }

        // --- 核心逻辑 ---

        function loadSourceTexture(sourceId) {
            // 1. 生成程序化纹理数据
            glObjects.textures.sourceData = textureGenerator.generate(sourceId, state.textureSize);
            
            // 2. 将数据上传到两个 GL 纹理对象
            uploadDataToTexture(glObjects.textures.texA, glObjects.textures.sourceData);
            uploadDataToTexture(glObjects.textures.texB, glObjects.textures.sourceData);
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // 检查 NPOT
                    if (!isPowerOfTwo(img.width) || !isPowerOfTwo(img.height)) {
                        console.warn(`Image ${img.width}x${img.height} is not power-of-two. Mipmaps might not work correctly.`);
                        // (在 WebGL 2.0+ 或支持 NPOT 扩展时这不是问题，但 Mipmaps 仍需 POT)
                    }
                    
                    glObjects.textures.sourceData = { image: img, width: img.width, height: img.height };
                    uploadDataToTexture(glObjects.textures.texA, glObjects.textures.sourceData);
                    uploadDataToTexture(glObjects.textures.texB, glObjects.textures.sourceData);
                    
                    // 更新状态
                    state.textureSource = file.name;
                    state.textureSize = img.width; // (假设正方形)
                    ui.textureSource.value = ''; // 清除下拉框
                    updateApp();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function isPowerOfTwo(value) {
            return (value & (value - 1)) === 0;
        }

        function uploadDataToTexture(texture, source) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            if (source.image) {
                // 来源是 Image 对象 (上传)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source.image);
            } else {
                // 来源是 Uint8Array (程序化)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.width, source.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, source.data);
            }
            
            // 生成 Mipmap
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }

        /** 将UI状态应用到GL纹理参数 */
        function updateTextureParameters() {
            // 检查 Anisotropy 控件是否应启用
            const anisoA = (state.filterA === 'anisotropic');
            const anisoB = (state.filterB === 'anisotropic');
            ui.anisotropyLevel.disabled = !(anisoA || anisoB) || !glObjects.extensions.aniso;

            // 配置 Texture A
            gl.bindTexture(gl.TEXTURE_2D, glObjects.textures.texA);
            applyFilterParameters(gl, state.filterA, anisoA ? state.anisotropyLevel : 1);

            // 配置 Texture B
            gl.bindTexture(gl.TEXTURE_2D, glObjects.textures.texB);
            applyFilterParameters(gl, state.filterB, anisoB ? state.anisotropyLevel : 1);
            
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        
        function applyFilterParameters(gl, filterName, anisoLevel) {
            const ext = glObjects.extensions.aniso;
            anisoLevel = ext ? anisoLevel : 1; // 如果不支持，则重置为1

            switch (filterName) {
                case 'nearest':
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 1.0);
                    break;
                case 'linear':
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 1.0);
                    break;
                case 'mipmap_nearest':
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
                    gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 1.0);
                    break;
                case 'mipmap_linear':
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, 1.0);
                    break;
                case 'anisotropic':
                    if (ext) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                        gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, anisoLevel);
                    } else {
                        // 降级
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    }
                    break;
            }
        }

        /** 将UI状态应用到变换矩阵 */
        function updateMatrices() {
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const scale = state.scale;
            const tiltRad = state.tilt * Math.PI / 180;
            const rotRad = state.rotation * Math.PI / 180;

            // 1. 投影矩阵
            if (state.projection === 'perspective') {
                mat4.perspective(matrices.projection, 45 * Math.PI / 180, aspect, 0.1, 100);
            } else {
                mat4.ortho(matrices.projection, -aspect, aspect, -1, 1, 0.1, 100);
            }

            // 2. 模型-视图矩阵
            mat4.identity(matrices.modelView);
            
            // 我们将相机放在z=2，看向原点
            // 物体在原点
            // 为了实现 "缩放"，我们移动相机
            // 为了实现 "倾斜"，我们旋转物体
            
            const z = 1.0 / (scale * 0.5); // 简单的缩放-距离映射
            mat4.translate(matrices.modelView, matrices.modelView, [0, 0, -z]);
            
            // 倾斜 (绕X轴旋转)
            mat4.rotateX(matrices.modelView, matrices.modelView, tiltRad);
            // 旋转 (绕Z轴旋转)
            mat4.rotateZ(matrices.modelView, matrices.modelView, rotRad);
        }
        
        /** 将JS状态同步回UI（例如重置或加载场景时） */
        function applyStateToUI() {
            ui.textureSource.value = state.textureSource;
            ui.filterA.value = state.filterA;
            ui.filterB.value = state.filterB;
            ui.anisotropyLevel.value = state.anisotropyLevel;
            ui.scale.value = state.scale;
            ui.scaleValue.textContent = state.scale.toFixed(2);
            ui.rotation.value = state.rotation;
            ui.rotationValue.textContent = state.rotation.toFixed(0);
            ui.tilt.value = state.tilt;
            ui.tiltValue.textContent = state.tilt.toFixed(0);
            ui.projection.value = state.projection;
            ui.debugOverlay.value = (state.debugMode > 0.5) ? 'mipmap_lod' : 'none';
        }

        /** 任何状态变化后调用的主更新函数 */
        function updateApp() {
            updateTextureParameters();
            updateMatrices();
        }

        // --- 渲染循环 ---
        
        function renderLoop(now) {
            requestAnimationFrame(renderLoop);

            // 检查画布是否需要调整大小
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                // 调整大小时需要更新矩阵
                updateMatrices();
            }

            // 计算FPS
            const delta = now - lastTime;
            lastTime = now;
            frameCount++;
            if (now % 1000 < delta) { // 每秒更新一次
                fps = frameCount;
                frameCount = 0;
                ui.fpsDisplay.textContent = `FPS: ${fps}`;
            }

            // --- 渲染 ---
            gl.clearColor(0.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(glObjects.program);

            // 绑定缓冲区 (实际上在 initBuffers 后已绑定)
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glObjects.buffers.indices);
            
            // 绑定纹理
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, glObjects.textures.texA);
            gl.uniform1i(glObjects.locations.u_texture_A, 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, glObjects.textures.texB);
            gl.uniform1i(glObjects.locations.u_texture_B, 1);
            
            // 设置 Uniforms
            gl.uniformMatrix4fv(glObjects.locations.u_projectionMatrix, false, matrices.projection);
            gl.uniformMatrix4fv(glObjects.locations.u_modelViewMatrix, false, matrices.modelView);
            
            gl.uniform1f(glObjects.locations.u_splitPosition_px, state.splitPosition * gl.canvas.width);
            gl.uniform1f(glObjects.locations.u_debugMode, state.debugMode);
            gl.uniform2f(glObjects.locations.u_textureSize, glObjects.textures.sourceData.width, glObjects.textures.sourceData.height);
            
            // 绘制
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        }

    </script>
</body>
</html>